// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: frontend_ios.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Frontend_DemandWaypointType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case pickUpPoint // = 0
  case dropOffPoint // = 1
  case waypoint // = 2
  case departurePoint // = 3
  case arrivalPoint // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .pickUpPoint
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .pickUpPoint
    case 1: self = .dropOffPoint
    case 2: self = .waypoint
    case 3: self = .departurePoint
    case 4: self = .arrivalPoint
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .pickUpPoint: return 0
    case .dropOffPoint: return 1
    case .waypoint: return 2
    case .departurePoint: return 3
    case .arrivalPoint: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Frontend_DemandWaypointType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Frontend_DemandWaypointType] = [
    .pickUpPoint,
    .dropOffPoint,
    .waypoint,
    .departurePoint,
    .arrivalPoint,
  ]
}

#endif  // swift(>=4.2)

public struct Frontend_UserStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userIdx: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Frontend_UserStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userStateWithInfo: [Frontend_UserStateWithInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Frontend_UserStateWithInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userState: Frontend_UserState {
    get {return _storage._userState ?? Frontend_UserState()}
    set {_uniqueStorage()._userState = newValue}
  }
  /// Returns true if `userState` has been explicitly set.
  public var hasUserState: Bool {return _storage._userState != nil}
  /// Clears the value of `userState`. Subsequent reads from it will return its default value.
  public mutating func clearUserState() {_uniqueStorage()._userState = nil}

  public var vehicleInfo: Frontend_VehicleInfo {
    get {return _storage._vehicleInfo ?? Frontend_VehicleInfo()}
    set {_uniqueStorage()._vehicleInfo = newValue}
  }
  /// Returns true if `vehicleInfo` has been explicitly set.
  public var hasVehicleInfo: Bool {return _storage._vehicleInfo != nil}
  /// Clears the value of `vehicleInfo`. Subsequent reads from it will return its default value.
  public mutating func clearVehicleInfo() {_uniqueStorage()._vehicleInfo = nil}

  public var fromLngLat: Frontend_LngLat {
    get {return _storage._fromLngLat ?? Frontend_LngLat()}
    set {_uniqueStorage()._fromLngLat = newValue}
  }
  /// Returns true if `fromLngLat` has been explicitly set.
  public var hasFromLngLat: Bool {return _storage._fromLngLat != nil}
  /// Clears the value of `fromLngLat`. Subsequent reads from it will return its default value.
  public mutating func clearFromLngLat() {_uniqueStorage()._fromLngLat = nil}

  public var fromWalkPath: Frontend_Path {
    get {return _storage._fromWalkPath ?? Frontend_Path()}
    set {_uniqueStorage()._fromWalkPath = newValue}
  }
  /// Returns true if `fromWalkPath` has been explicitly set.
  public var hasFromWalkPath: Bool {return _storage._fromWalkPath != nil}
  /// Clears the value of `fromWalkPath`. Subsequent reads from it will return its default value.
  public mutating func clearFromWalkPath() {_uniqueStorage()._fromWalkPath = nil}

  public var toLngLat: Frontend_LngLat {
    get {return _storage._toLngLat ?? Frontend_LngLat()}
    set {_uniqueStorage()._toLngLat = newValue}
  }
  /// Returns true if `toLngLat` has been explicitly set.
  public var hasToLngLat: Bool {return _storage._toLngLat != nil}
  /// Clears the value of `toLngLat`. Subsequent reads from it will return its default value.
  public mutating func clearToLngLat() {_uniqueStorage()._toLngLat = nil}

  public var toWalkPath: Frontend_Path {
    get {return _storage._toWalkPath ?? Frontend_Path()}
    set {_uniqueStorage()._toWalkPath = newValue}
  }
  /// Returns true if `toWalkPath` has been explicitly set.
  public var hasToWalkPath: Bool {return _storage._toWalkPath != nil}
  /// Clears the value of `toWalkPath`. Subsequent reads from it will return its default value.
  public mutating func clearToWalkPath() {_uniqueStorage()._toWalkPath = nil}

  public var itemDetail: String {
    get {return _storage._itemDetail}
    set {_uniqueStorage()._itemDetail = newValue}
  }

  public var pickUpEta: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._pickUpEta ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._pickUpEta = newValue}
  }
  /// Returns true if `pickUpEta` has been explicitly set.
  public var hasPickUpEta: Bool {return _storage._pickUpEta != nil}
  /// Clears the value of `pickUpEta`. Subsequent reads from it will return its default value.
  public mutating func clearPickUpEta() {_uniqueStorage()._pickUpEta = nil}

  public var dropOffEta: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._dropOffEta ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._dropOffEta = newValue}
  }
  /// Returns true if `dropOffEta` has been explicitly set.
  public var hasDropOffEta: Bool {return _storage._dropOffEta != nil}
  /// Clears the value of `dropOffEta`. Subsequent reads from it will return its default value.
  public mutating func clearDropOffEta() {_uniqueStorage()._dropOffEta = nil}

  public var supplyWaypointList: [Frontend_SupplyWaypoint] {
    get {return _storage._supplyWaypointList}
    set {_uniqueStorage()._supplyWaypointList = newValue}
  }

  public var supplyWaypointPathList: [Frontend_Path] {
    get {return _storage._supplyWaypointPathList}
    set {_uniqueStorage()._supplyWaypointPathList = newValue}
  }

  public var pickUpPathSeq: Int32 {
    get {return _storage._pickUpPathSeq}
    set {_uniqueStorage()._pickUpPathSeq = newValue}
  }

  public var dropOffPathSeq: Int32 {
    get {return _storage._dropOffPathSeq}
    set {_uniqueStorage()._dropOffPathSeq = newValue}
  }

  public var supplyWaypointVersion: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._supplyWaypointVersion ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._supplyWaypointVersion = newValue}
  }
  /// Returns true if `supplyWaypointVersion` has been explicitly set.
  public var hasSupplyWaypointVersion: Bool {return _storage._supplyWaypointVersion != nil}
  /// Clears the value of `supplyWaypointVersion`. Subsequent reads from it will return its default value.
  public mutating func clearSupplyWaypointVersion() {_uniqueStorage()._supplyWaypointVersion = nil}

  public var supplyWaypointEtaVersion: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._supplyWaypointEtaVersion ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._supplyWaypointEtaVersion = newValue}
  }
  /// Returns true if `supplyWaypointEtaVersion` has been explicitly set.
  public var hasSupplyWaypointEtaVersion: Bool {return _storage._supplyWaypointEtaVersion != nil}
  /// Clears the value of `supplyWaypointEtaVersion`. Subsequent reads from it will return its default value.
  public mutating func clearSupplyWaypointEtaVersion() {_uniqueStorage()._supplyWaypointEtaVersion = nil}

  public var supplyWaypointPathVersion: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._supplyWaypointPathVersion ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._supplyWaypointPathVersion = newValue}
  }
  /// Returns true if `supplyWaypointPathVersion` has been explicitly set.
  public var hasSupplyWaypointPathVersion: Bool {return _storage._supplyWaypointPathVersion != nil}
  /// Clears the value of `supplyWaypointPathVersion`. Subsequent reads from it will return its default value.
  public mutating func clearSupplyWaypointPathVersion() {_uniqueStorage()._supplyWaypointPathVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Frontend_GetSupplyLocationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var supplyIdx: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Frontend_SupplyStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var supplyState: [Frontend_SupplyState] = []

  public var supplyWaypointList: [Frontend_SupplyWaypoint] = []

  public var supplyWaypointEtaList: [Frontend_SupplyWaypointEta] = []

  public var supplyWaypointPathList: [Frontend_SupplyWaypointPath] = []

  public var supplyWaypointVersion: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _supplyWaypointVersion ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_supplyWaypointVersion = newValue}
  }
  /// Returns true if `supplyWaypointVersion` has been explicitly set.
  public var hasSupplyWaypointVersion: Bool {return self._supplyWaypointVersion != nil}
  /// Clears the value of `supplyWaypointVersion`. Subsequent reads from it will return its default value.
  public mutating func clearSupplyWaypointVersion() {self._supplyWaypointVersion = nil}

  public var supplyWaypointEtaVersion: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _supplyWaypointEtaVersion ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_supplyWaypointEtaVersion = newValue}
  }
  /// Returns true if `supplyWaypointEtaVersion` has been explicitly set.
  public var hasSupplyWaypointEtaVersion: Bool {return self._supplyWaypointEtaVersion != nil}
  /// Clears the value of `supplyWaypointEtaVersion`. Subsequent reads from it will return its default value.
  public mutating func clearSupplyWaypointEtaVersion() {self._supplyWaypointEtaVersion = nil}

  public var supplyWaypointPathVersion: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _supplyWaypointPathVersion ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_supplyWaypointPathVersion = newValue}
  }
  /// Returns true if `supplyWaypointPathVersion` has been explicitly set.
  public var hasSupplyWaypointPathVersion: Bool {return self._supplyWaypointPathVersion != nil}
  /// Clears the value of `supplyWaypointPathVersion`. Subsequent reads from it will return its default value.
  public mutating func clearSupplyWaypointPathVersion() {self._supplyWaypointPathVersion = nil}

  public var recentStopIdx: Int32 = 0

  public var visitType: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _supplyWaypointVersion: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _supplyWaypointEtaVersion: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _supplyWaypointPathVersion: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Frontend_SupplyLocationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var loc: Frontend_Loc {
    get {return _loc ?? Frontend_Loc()}
    set {_loc = newValue}
  }
  /// Returns true if `loc` has been explicitly set.
  public var hasLoc: Bool {return self._loc != nil}
  /// Clears the value of `loc`. Subsequent reads from it will return its default value.
  public mutating func clearLoc() {self._loc = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _loc: Frontend_Loc? = nil
}

public struct Frontend_SupplyLocationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var supplyLocationMatched: Frontend_SupplyLocationMatched {
    get {return _supplyLocationMatched ?? Frontend_SupplyLocationMatched()}
    set {_supplyLocationMatched = newValue}
  }
  /// Returns true if `supplyLocationMatched` has been explicitly set.
  public var hasSupplyLocationMatched: Bool {return self._supplyLocationMatched != nil}
  /// Clears the value of `supplyLocationMatched`. Subsequent reads from it will return its default value.
  public mutating func clearSupplyLocationMatched() {self._supplyLocationMatched = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _supplyLocationMatched: Frontend_SupplyLocationMatched? = nil
}

public struct Frontend_FrontEndDispatchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userIdx: Int32 {
    get {return _storage._userIdx}
    set {_uniqueStorage()._userIdx = newValue}
  }

  public var regionCode: Int32 {
    get {return _storage._regionCode}
    set {_uniqueStorage()._regionCode = newValue}
  }

  public var itemCount: Int32 {
    get {return _storage._itemCount}
    set {_uniqueStorage()._itemCount = newValue}
  }

  public var itemType: String {
    get {return _storage._itemType}
    set {_uniqueStorage()._itemType = newValue}
  }

  public var itemDetail: String {
    get {return _storage._itemDetail}
    set {_uniqueStorage()._itemDetail = newValue}
  }

  public var demandType: String {
    get {return _storage._demandType}
    set {_uniqueStorage()._demandType = newValue}
  }

  public var pickUpStopIdx: Int32 {
    get {return _storage._pickUpStopIdx}
    set {_uniqueStorage()._pickUpStopIdx = newValue}
  }

  public var dropOffStopIdx: Int32 {
    get {return _storage._dropOffStopIdx}
    set {_uniqueStorage()._dropOffStopIdx = newValue}
  }

  public var fromWalkPath: String {
    get {return _storage._fromWalkPath}
    set {_uniqueStorage()._fromWalkPath = newValue}
  }

  public var toWalkPath: String {
    get {return _storage._toWalkPath}
    set {_uniqueStorage()._toWalkPath = newValue}
  }

  public var fromLngLat: Frontend_LngLat {
    get {return _storage._fromLngLat ?? Frontend_LngLat()}
    set {_uniqueStorage()._fromLngLat = newValue}
  }
  /// Returns true if `fromLngLat` has been explicitly set.
  public var hasFromLngLat: Bool {return _storage._fromLngLat != nil}
  /// Clears the value of `fromLngLat`. Subsequent reads from it will return its default value.
  public mutating func clearFromLngLat() {_uniqueStorage()._fromLngLat = nil}

  public var fromPoi: String {
    get {return _storage._fromPoi}
    set {_uniqueStorage()._fromPoi = newValue}
  }

  public var toLngLat: Frontend_LngLat {
    get {return _storage._toLngLat ?? Frontend_LngLat()}
    set {_uniqueStorage()._toLngLat = newValue}
  }
  /// Returns true if `toLngLat` has been explicitly set.
  public var hasToLngLat: Bool {return _storage._toLngLat != nil}
  /// Clears the value of `toLngLat`. Subsequent reads from it will return its default value.
  public mutating func clearToLngLat() {_uniqueStorage()._toLngLat = nil}

  public var toPoi: String {
    get {return _storage._toPoi}
    set {_uniqueStorage()._toPoi = newValue}
  }

  public var pickUpLngLat: Frontend_LngLat {
    get {return _storage._pickUpLngLat ?? Frontend_LngLat()}
    set {_uniqueStorage()._pickUpLngLat = newValue}
  }
  /// Returns true if `pickUpLngLat` has been explicitly set.
  public var hasPickUpLngLat: Bool {return _storage._pickUpLngLat != nil}
  /// Clears the value of `pickUpLngLat`. Subsequent reads from it will return its default value.
  public mutating func clearPickUpLngLat() {_uniqueStorage()._pickUpLngLat = nil}

  public var pickUpPoi: String {
    get {return _storage._pickUpPoi}
    set {_uniqueStorage()._pickUpPoi = newValue}
  }

  public var dropOffLngLat: Frontend_LngLat {
    get {return _storage._dropOffLngLat ?? Frontend_LngLat()}
    set {_uniqueStorage()._dropOffLngLat = newValue}
  }
  /// Returns true if `dropOffLngLat` has been explicitly set.
  public var hasDropOffLngLat: Bool {return _storage._dropOffLngLat != nil}
  /// Clears the value of `dropOffLngLat`. Subsequent reads from it will return its default value.
  public mutating func clearDropOffLngLat() {_uniqueStorage()._dropOffLngLat = nil}

  public var dropOffPoi: String {
    get {return _storage._dropOffPoi}
    set {_uniqueStorage()._dropOffPoi = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Frontend_FrontEndDispatchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var isSuccess: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Frontend_VehicleInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var supplyID: Int32 = 0

  public var supplyLoc: Frontend_LngLat {
    get {return _supplyLoc ?? Frontend_LngLat()}
    set {_supplyLoc = newValue}
  }
  /// Returns true if `supplyLoc` has been explicitly set.
  public var hasSupplyLoc: Bool {return self._supplyLoc != nil}
  /// Clears the value of `supplyLoc`. Subsequent reads from it will return its default value.
  public mutating func clearSupplyLoc() {self._supplyLoc = nil}

  public var direction: Float = 0

  public var speed: Float = 0

  public var supplyName: String = String()

  public var numberPlate: String = String()

  public var driverName: String = String()

  public var drvierImageURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _supplyLoc: Frontend_LngLat? = nil
}

public struct Frontend_DemandWaypoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var seq: Int32 = 0

  public var stopIdx: Int32 = 0

  public var name: String = String()

  public var waypointLngLat: Frontend_LngLat {
    get {return _waypointLngLat ?? Frontend_LngLat()}
    set {_waypointLngLat = newValue}
  }
  /// Returns true if `waypointLngLat` has been explicitly set.
  public var hasWaypointLngLat: Bool {return self._waypointLngLat != nil}
  /// Clears the value of `waypointLngLat`. Subsequent reads from it will return its default value.
  public mutating func clearWaypointLngLat() {self._waypointLngLat = nil}

  public var waypointType: Frontend_DemandWaypointType = .pickUpPoint

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _waypointLngLat: Frontend_LngLat? = nil
}

public struct Frontend_SetDispatchCancelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userIdx: Int32 = 0

  public var regionCode: Int32 = 0

  public var demandID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Frontend_SetArrivalWaypointRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var supplyIdx: Int32 = 0

  public var stopIdx: Int32 = 0

  public var regionCode: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Frontend_Path {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var links: [Frontend_Link] = []

  /// The total distance of the path in meter
  public var dist: Double = 0

  /// The total duration of the path in msec
  public var duration: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Frontend_Link {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  public var length: Double = 0

  public var duration: Int64 = 0

  public var lnglats: [Frontend_LngLat] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Frontend_Loc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lnglat: Frontend_LngLat {
    get {return _lnglat ?? Frontend_LngLat()}
    set {_lnglat = newValue}
  }
  /// Returns true if `lnglat` has been explicitly set.
  public var hasLnglat: Bool {return self._lnglat != nil}
  /// Clears the value of `lnglat`. Subsequent reads from it will return its default value.
  public mutating func clearLnglat() {self._lnglat = nil}

  public var accuracy: Float = 0

  /// Current heading value from 0 to 360 degrees
  public var heading: Float = 0

  /// Current speed in meter per second
  public var speed: Float = 0

  public var getDate: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lnglat: Frontend_LngLat? = nil
}

public struct Frontend_UserState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userIdx: Int32 = 0

  public var state: Int32 = 0

  public var supplyIdx: Int32 = 0

  public var demandID: String = String()

  public var enqueueEventTime: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Redis ÀúÀå±¸Á¶
public struct Frontend_SupplyState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var supplyIdx: Int32 = 0

  public var state: Int32 = 0

  public var enqueueEventTime: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Redis ÀúÀå±¸Á¶
public struct Frontend_SupplyLocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var supplyIdx: Int32 = 0

  public var deviceID: String = String()

  public var loc: Frontend_Loc {
    get {return _loc ?? Frontend_Loc()}
    set {_loc = newValue}
  }
  /// Returns true if `loc` has been explicitly set.
  public var hasLoc: Bool {return self._loc != nil}
  /// Clears the value of `loc`. Subsequent reads from it will return its default value.
  public mutating func clearLoc() {self._loc = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _loc: Frontend_Loc? = nil
}

/// ÁÖ¾îÁø °æ·Î À§ÀÇ Â÷·®ÃøÀ§ º¸Á¤°ª
public struct Frontend_SupplyLocationMatched {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var supplyID: Int32 = 0

  /// SupplyLocation¿¡¼­ ¼öÁýÇÑ ¿øº» ÃøÀ§ÁÂÇ¥ 
  public var rawLngLat: Frontend_LngLat {
    get {return _rawLngLat ?? Frontend_LngLat()}
    set {_rawLngLat = newValue}
  }
  /// Returns true if `rawLngLat` has been explicitly set.
  public var hasRawLngLat: Bool {return self._rawLngLat != nil}
  /// Clears the value of `rawLngLat`. Subsequent reads from it will return its default value.
  public mutating func clearRawLngLat() {self._rawLngLat = nil}

  /// ±âÁØÀÌ µÈ °æ·Î(SupplyWaypointPath)ÀÇ ¹öÀü
  public var pathVersion: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _pathVersion ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_pathVersion = newValue}
  }
  /// Returns true if `pathVersion` has been explicitly set.
  public var hasPathVersion: Bool {return self._pathVersion != nil}
  /// Clears the value of `pathVersion`. Subsequent reads from it will return its default value.
  public mutating func clearPathVersion() {self._pathVersion = nil}

  /// ÇØ´ç ¸Þ½ÃÁö°¡ ¾øÀ» ½Ã ¿øº» ÁÂÇ¥¸¸ ½Å·Ú°¡´É.
  /// Ã£Áö ¸øÇßÀ»¶§ ±âÁ¸ÀÇ ¸¶Áö¸· °ªÀ» Àü´ÞÇØ¾ßÇÒÁö ¹ÌÁ¤.
  /// ÀûÀýÇÑ À¯È¿¼º ÆÇ´Ü ·ÎÁ÷ÀÌ Ãß°¡µÉ¶§±îÁö´Â °æ·Î°¡ Á¸ÀçÇÏ´Â ÇÑ Ç×»ó true.
  public var matchResult: Frontend_SupplyLocationMatched.Matched {
    get {return _matchResult ?? Frontend_SupplyLocationMatched.Matched()}
    set {_matchResult = newValue}
  }
  /// Returns true if `matchResult` has been explicitly set.
  public var hasMatchResult: Bool {return self._matchResult != nil}
  /// Clears the value of `matchResult`. Subsequent reads from it will return its default value.
  public mutating func clearMatchResult() {self._matchResult = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Matched {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// SupplyWaypointPathsÀÇ °æ·Î¸¦ ±âÁØÀ¸·ÎÇÑ °¢°¢ÀÇ »öÀÎ°ª.	ÇöÀç path_index´Â 0(Â÷·®->Ã¹¹øÂ° °æÀ¯Áö)À¸·Î °íÁ¤.
    public var pathIndex: Int32 = 0

    public var linkIndex: Int32 = 0

    public var lngLatIndex: Int32 = 0

    /// °æ·Î»ó¿¡ Æ÷ÇÔµÇµµ·Ï º¸Á¤µÈ ÁÂÇ¥. ·»´õ¸µ ½Ã °æ·Î¸¦ ÀÌ ÁÂÇ¥ºÎÅÍ ±×¸®¸é µË´Ï´Ù.
    public var adjustedLngLat: Frontend_LngLat {
      get {return _adjustedLngLat ?? Frontend_LngLat()}
      set {_adjustedLngLat = newValue}
    }
    /// Returns true if `adjustedLngLat` has been explicitly set.
    public var hasAdjustedLngLat: Bool {return self._adjustedLngLat != nil}
    /// Clears the value of `adjustedLngLat`. Subsequent reads from it will return its default value.
    public mutating func clearAdjustedLngLat() {self._adjustedLngLat = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _adjustedLngLat: Frontend_LngLat? = nil
  }

  public init() {}

  fileprivate var _rawLngLat: Frontend_LngLat? = nil
  fileprivate var _pathVersion: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _matchResult: Frontend_SupplyLocationMatched.Matched? = nil
}

/// ±âÁ¸ api ÀÀ´ä ¾ç½Ä È£È¯ (userApp)
public struct Frontend_SupplyWaypoints {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var supplyWaypoint: [Frontend_SupplyWaypoint] = []

  public var getDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _getDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_getDate = newValue}
  }
  /// Returns true if `getDate` has been explicitly set.
  public var hasGetDate: Bool {return self._getDate != nil}
  /// Clears the value of `getDate`. Subsequent reads from it will return its default value.
  public mutating func clearGetDate() {self._getDate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _getDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// º¯°æ¾È
public struct Frontend_SupplyWaypointUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var supplyID: Int32 {
    get {return _storage._supplyID}
    set {_uniqueStorage()._supplyID = newValue}
  }

  /// ½º³À¼¦ ¹ß»ý½Ã°¢ yyyy-MM-dd hh:mm:ss.ffffff ( Timestamp Æ÷¸Ë + UTC ·Î ÀüÈ¯ÇÏ´Â ÆíÀÌ ¹Ù¶÷Á÷ )
  public var waypointVersion: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._waypointVersion ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._waypointVersion = newValue}
  }
  /// Returns true if `waypointVersion` has been explicitly set.
  public var hasWaypointVersion: Bool {return _storage._waypointVersion != nil}
  /// Clears the value of `waypointVersion`. Subsequent reads from it will return its default value.
  public mutating func clearWaypointVersion() {_uniqueStorage()._waypointVersion = nil}

  /// °æÀ¯Áö °»½ÅÀ» ÀÏÀ¸Å² ¾×¼Ç
  public var action: Frontend_SupplyWaypointUpdate.WaypointActionType {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  /// ¾×¼Çº° »ó¼¼Á¤º¸
  public var actionDetail: OneOf_ActionDetail? {
    get {return _storage._actionDetail}
    set {_uniqueStorage()._actionDetail = newValue}
  }

  public var dispatchDetail: Frontend_SupplyWaypointUpdate.DispatchDetail {
    get {
      if case .dispatchDetail(let v)? = _storage._actionDetail {return v}
      return Frontend_SupplyWaypointUpdate.DispatchDetail()
    }
    set {_uniqueStorage()._actionDetail = .dispatchDetail(newValue)}
  }

  public var arrivalDetail: Frontend_SupplyWaypointUpdate.ArrivalDetail {
    get {
      if case .arrivalDetail(let v)? = _storage._actionDetail {return v}
      return Frontend_SupplyWaypointUpdate.ArrivalDetail()
    }
    set {_uniqueStorage()._actionDetail = .arrivalDetail(newValue)}
  }

  public var cancelDetail: Frontend_SupplyWaypointUpdate.CancelDetail {
    get {
      if case .cancelDetail(let v)? = _storage._actionDetail {return v}
      return Frontend_SupplyWaypointUpdate.CancelDetail()
    }
    set {_uniqueStorage()._actionDetail = .cancelDetail(newValue)}
  }

  /// °æÀ¯Áö ¸ñ·Ï ½º³À¼¦ - °»½Å ÈÄ 
  public var supplyWaypointList: [Frontend_SupplyWaypoint] {
    get {return _storage._supplyWaypointList}
    set {_uniqueStorage()._supplyWaypointList = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// ¾×¼Çº° »ó¼¼Á¤º¸
  public enum OneOf_ActionDetail: Equatable {
    case dispatchDetail(Frontend_SupplyWaypointUpdate.DispatchDetail)
    case arrivalDetail(Frontend_SupplyWaypointUpdate.ArrivalDetail)
    case cancelDetail(Frontend_SupplyWaypointUpdate.CancelDetail)

  #if !swift(>=4.1)
    public static func ==(lhs: Frontend_SupplyWaypointUpdate.OneOf_ActionDetail, rhs: Frontend_SupplyWaypointUpdate.OneOf_ActionDetail) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.dispatchDetail, .dispatchDetail): return {
        guard case .dispatchDetail(let l) = lhs, case .dispatchDetail(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.arrivalDetail, .arrivalDetail): return {
        guard case .arrivalDetail(let l) = lhs, case .arrivalDetail(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cancelDetail, .cancelDetail): return {
        guard case .cancelDetail(let l) = lhs, case .cancelDetail(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// °æÀ¯Áö °»½Å ¾×¼Ç ¸ñ·Ï
  public enum WaypointActionType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case dispatch // = 0
    case arrival // = 1
    case cancel // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .dispatch
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .dispatch
      case 1: self = .arrival
      case 2: self = .cancel
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .dispatch: return 0
      case .arrival: return 1
      case .cancel: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// ½Å±Ô¹èÂ÷ÀÚ °æÀ¯Áö ÀÎµ¦½º (Çö ½º³À¼¦ ±âÁØ)
  public struct DispatchDetail {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var demandID: String = String()

    public var pickWaypointSequence: Int32 = 0

    public var dropWaypointSequence: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ArrivalDetail {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// µµÂøÃ³¸® °£ Á¦°ÅµÈ Á¤·ùÀåÀÇ ½ÂÇÏÂ÷ Á¤º¸ (¿øº»À» ±×´ë·Î copyÇÏ¿© ³ë¼î ½Â°´ Æ÷ÇÔ)
    public var removedWaypoint: Frontend_SupplyWaypoint {
      get {return _removedWaypoint ?? Frontend_SupplyWaypoint()}
      set {_removedWaypoint = newValue}
    }
    /// Returns true if `removedWaypoint` has been explicitly set.
    public var hasRemovedWaypoint: Bool {return self._removedWaypoint != nil}
    /// Clears the value of `removedWaypoint`. Subsequent reads from it will return its default value.
    public mutating func clearRemovedWaypoint() {self._removedWaypoint = nil}

    /// ³ë¼î ÁÖ¹®µéÀÇ ID ¹× ÇÏÂ÷Áö
    public var noshowDropinfoList: [Frontend_SupplyWaypointUpdate.DemandStationInfoFromPrev] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _removedWaypoint: Frontend_SupplyWaypoint? = nil
  }

  public struct CancelDetail {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var demandID: String = String()

    /// ÁÖ¹®Ãë¼Ò ½ÂÂ÷Áö Á¤º¸
    public var canceledInfoPick: Frontend_SupplyWaypointUpdate.DemandStationInfoFromPrev {
      get {return _canceledInfoPick ?? Frontend_SupplyWaypointUpdate.DemandStationInfoFromPrev()}
      set {_canceledInfoPick = newValue}
    }
    /// Returns true if `canceledInfoPick` has been explicitly set.
    public var hasCanceledInfoPick: Bool {return self._canceledInfoPick != nil}
    /// Clears the value of `canceledInfoPick`. Subsequent reads from it will return its default value.
    public mutating func clearCanceledInfoPick() {self._canceledInfoPick = nil}

    /// ÁÖ¹®Ãë¼Ò ÇÏÂ÷Áö Á¤º¸
    public var canceledInfoDrop: Frontend_SupplyWaypointUpdate.DemandStationInfoFromPrev {
      get {return _canceledInfoDrop ?? Frontend_SupplyWaypointUpdate.DemandStationInfoFromPrev()}
      set {_canceledInfoDrop = newValue}
    }
    /// Returns true if `canceledInfoDrop` has been explicitly set.
    public var hasCanceledInfoDrop: Bool {return self._canceledInfoDrop != nil}
    /// Clears the value of `canceledInfoDrop`. Subsequent reads from it will return its default value.
    public mutating func clearCanceledInfoDrop() {self._canceledInfoDrop = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _canceledInfoPick: Frontend_SupplyWaypointUpdate.DemandStationInfoFromPrev? = nil
    fileprivate var _canceledInfoDrop: Frontend_SupplyWaypointUpdate.DemandStationInfoFromPrev? = nil
  }

  /// Á÷Àü ¹öÀü supply_waypoint_list¿¡¼­ °¡Á®¿Â µ¥ÀÌÅÍ °øÅë¾ç½Ä
  public struct DemandStationInfoFromPrev {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var demandID: String = String()

    public var stopIdx: Int32 = 0

    /// from previous snapshot.
    public var waypointSeq: Int32 = 0

    public var waypointLngLat: Frontend_LngLat {
      get {return _waypointLngLat ?? Frontend_LngLat()}
      set {_waypointLngLat = newValue}
    }
    /// Returns true if `waypointLngLat` has been explicitly set.
    public var hasWaypointLngLat: Bool {return self._waypointLngLat != nil}
    /// Clears the value of `waypointLngLat`. Subsequent reads from it will return its default value.
    public mutating func clearWaypointLngLat() {self._waypointLngLat = nil}

    public var waypointName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _waypointLngLat: Frontend_LngLat? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Frontend_SupplyWaypointUpdate.WaypointActionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Frontend_SupplyWaypointUpdate.WaypointActionType] = [
    .dispatch,
    .arrival,
    .cancel,
  ]
}

#endif  // swift(>=4.2)

public struct Frontend_SupplyWaypoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var supplyID: Int32 = 0

  public var stopIdx: Int32 = 0

  public var waypointSeq: Int32 = 0

  public var waypointLngLat: Frontend_LngLat {
    get {return _waypointLngLat ?? Frontend_LngLat()}
    set {_waypointLngLat = newValue}
  }
  /// Returns true if `waypointLngLat` has been explicitly set.
  public var hasWaypointLngLat: Bool {return self._waypointLngLat != nil}
  /// Clears the value of `waypointLngLat`. Subsequent reads from it will return its default value.
  public mutating func clearWaypointLngLat() {self._waypointLngLat = nil}

  public var waypointName: String = String()

  public var waypointDesc: String = String()

  public var waypointType: Frontend_SupplyWaypoint.SupplyWaypointType = .pickDrop

  public var pickUpDemandIDList: [String] = []

  public var dropOffDemandIDList: [String] = []

  public var pickUpUserIDList: [Int32] = []

  public var dropOffUserIDList: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum SupplyWaypointType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case pickDrop // = 0
    case cancel // = 1
    case parking // = 2
    case garage // = 3
    case rest // = 4
    case relocation // = 5
    case prediction // = 6
    case rotation // = 7
    case repair // = 8

    /// »çÀüÀÔ·ÂµÈ ³ë¼± °æÀ¯Áö
    case route // = 9
    case UNRECOGNIZED(Int)

    public init() {
      self = .pickDrop
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .pickDrop
      case 1: self = .cancel
      case 2: self = .parking
      case 3: self = .garage
      case 4: self = .rest
      case 5: self = .relocation
      case 6: self = .prediction
      case 7: self = .rotation
      case 8: self = .repair
      case 9: self = .route
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .pickDrop: return 0
      case .cancel: return 1
      case .parking: return 2
      case .garage: return 3
      case .rest: return 4
      case .relocation: return 5
      case .prediction: return 6
      case .rotation: return 7
      case .repair: return 8
      case .route: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _waypointLngLat: Frontend_LngLat? = nil
}

#if swift(>=4.2)

extension Frontend_SupplyWaypoint.SupplyWaypointType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Frontend_SupplyWaypoint.SupplyWaypointType] = [
    .pickDrop,
    .cancel,
    .parking,
    .garage,
    .rest,
    .relocation,
    .prediction,
    .rotation,
    .repair,
    .route,
  ]
}

#endif  // swift(>=4.2)

/// ±âÁ¸ api È£È¯À§ÇØ À¯Áö (userApp)
public struct Frontend_SupplyWaypointPaths {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var supplyWaypointPath: [Frontend_SupplyWaypointPath] = []

  public var getDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _getDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_getDate = newValue}
  }
  /// Returns true if `getDate` has been explicitly set.
  public var hasGetDate: Bool {return self._getDate != nil}
  /// Clears the value of `getDate`. Subsequent reads from it will return its default value.
  public mutating func clearGetDate() {self._getDate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _getDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// º¯°æ¾È
public struct Frontend_SupplyWaypointPathUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var supplyID: Int32 = 0

  public var pathVersion: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _pathVersion ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_pathVersion = newValue}
  }
  /// Returns true if `pathVersion` has been explicitly set.
  public var hasPathVersion: Bool {return self._pathVersion != nil}
  /// Clears the value of `pathVersion`. Subsequent reads from it will return its default value.
  public mutating func clearPathVersion() {self._pathVersion = nil}

  /// °æ·Î °è»ê½Ã »ç¿ëµÈ °æÀ¯Áö ¹öÀü (join keyÀÇ ÀÏºÎ)
  public var waypointVersion: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _waypointVersion ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_waypointVersion = newValue}
  }
  /// Returns true if `waypointVersion` has been explicitly set.
  public var hasWaypointVersion: Bool {return self._waypointVersion != nil}
  /// Clears the value of `waypointVersion`. Subsequent reads from it will return its default value.
  public mutating func clearWaypointVersion() {self._waypointVersion = nil}

  public var action: Frontend_SupplyWaypointPathUpdate.PathActionType = .waypointUpdate

  public var supplyWaypointPathList: [Frontend_SupplyWaypointPath] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum PathActionType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// °æÀ¯Áö º¯°æÀ¸·Î ÀÎÇÑ °»½Å
    case waypointUpdate // = 0

    /// ÁÖÇà°æ·Î ÀÌÅ»·Î ÀÎÇÑ °»½Å
    case offtrack // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .waypointUpdate
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .waypointUpdate
      case 1: self = .offtrack
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .waypointUpdate: return 0
      case .offtrack: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _pathVersion: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _waypointVersion: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Frontend_SupplyWaypointPathUpdate.PathActionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Frontend_SupplyWaypointPathUpdate.PathActionType] = [
    .waypointUpdate,
    .offtrack,
  ]
}

#endif  // swift(>=4.2)

/// TODO: path ¿Ü¿¡ ÀüºÎ Áßº¹ µ¥ÀÌÅÍ. ¾Û°úÀÇ È£È¯¼ºÀ» À§ÇØ ¾ç½Ä À¯ÁöÇÏ°í Â÷ÈÄ ÇÊ¿ä¿¡ µû¶ó Áßº¹Á¦°Å
public struct Frontend_SupplyWaypointPath {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var supplyID: Int32 = 0

  public var waypointSeq: Int32 = 0

  ///repeated string pick_up_demand_id_list = 4;
  ///repeated string drop_off_demand_id_list = 5;
  ///repeated int32 pick_up_user_id_list = 6;
  ///repeated int32 drop_off_user_id_list = 7;
  public var path: Frontend_Path {
    get {return _path ?? Frontend_Path()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  public var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  public mutating func clearPath() {self._path = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _path: Frontend_Path? = nil
}

/// #3 ETA °»½Å ¸Þ½ÃÁö
/// ±âÁ¸ ¾ç½Ä À¯Áö
public struct Frontend_SupplyWaypointEtas {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var supplyWaypointEta: [Frontend_SupplyWaypointEta] = []

  public var getDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _getDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_getDate = newValue}
  }
  /// Returns true if `getDate` has been explicitly set.
  public var hasGetDate: Bool {return self._getDate != nil}
  /// Clears the value of `getDate`. Subsequent reads from it will return its default value.
  public mutating func clearGetDate() {self._getDate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _getDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// º¯°æ¾È
public struct Frontend_SupplyWaypointEtaUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var supplyID: Int32 = 0

  public var etaVersion: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _etaVersion ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_etaVersion = newValue}
  }
  /// Returns true if `etaVersion` has been explicitly set.
  public var hasEtaVersion: Bool {return self._etaVersion != nil}
  /// Clears the value of `etaVersion`. Subsequent reads from it will return its default value.
  public mutating func clearEtaVersion() {self._etaVersion = nil}

  /// °æ·Î °è»ê½Ã »ç¿ëµÈ °æÀ¯Áö ¹öÀü (join keyÀÇ ÀÏºÎ)
  public var waypointVersion: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _waypointVersion ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_waypointVersion = newValue}
  }
  /// Returns true if `waypointVersion` has been explicitly set.
  public var hasWaypointVersion: Bool {return self._waypointVersion != nil}
  /// Clears the value of `waypointVersion`. Subsequent reads from it will return its default value.
  public mutating func clearWaypointVersion() {self._waypointVersion = nil}

  public var action: Frontend_SupplyWaypointEtaUpdate.EtaActionType = .waypointUpdate

  public var supplyWaypointEtaList: [Frontend_SupplyWaypointEta] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum EtaActionType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// °æÀ¯Áö º¯°æÀ¸·Î ÀÎÇÑ °»½Å
    case waypointUpdate // = 0

    /// ÁÖÇà°æ·Î ÀÌÅ»·Î ÀÎÇÑ °æ·Î Àç°è»ê ÈÄ °»½Å
    case pathOfftrack // = 1

    /// ±âÁ¸ ETA ´ëºñ Â÷ÀÌ°¡ ½ÉÇÒ¶§ °»½Å
    case etaOfftrack // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .waypointUpdate
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .waypointUpdate
      case 1: self = .pathOfftrack
      case 2: self = .etaOfftrack
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .waypointUpdate: return 0
      case .pathOfftrack: return 1
      case .etaOfftrack: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _etaVersion: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _waypointVersion: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Frontend_SupplyWaypointEtaUpdate.EtaActionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Frontend_SupplyWaypointEtaUpdate.EtaActionType] = [
    .waypointUpdate,
    .pathOfftrack,
    .etaOfftrack,
  ]
}

#endif  // swift(>=4.2)

public struct Frontend_SupplyWaypointEta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var supplyID: Int32 = 0

  public var waypointSeq: Int32 = 0

  ///repeated string pick_up_demand_id_list = 4;
  ///repeated string drop_off_demand_id_list = 5;
  ///repeated int32 pick_up_user_id_list = 6;
  ///repeated int32 drop_off_user_id_list = 7;
  public var eta: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _eta ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_eta = newValue}
  }
  /// Returns true if `eta` has been explicitly set.
  public var hasEta: Bool {return self._eta != nil}
  /// Clears the value of `eta`. Subsequent reads from it will return its default value.
  public mutating func clearEta() {self._eta = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _eta: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// rpc #1 ´Ü¼ø °æ·ÎÁ¶È¸ (with Á¤·ùÀåID)
public struct Frontend_FindPathRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var regionCode: Int32 = 0

  public var pickStationID: String = String()

  public var dropStationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Frontend_FindPathReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var regionCode: Int32 = 0

  public var path: Frontend_Path {
    get {return _path ?? Frontend_Path()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  public var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  public mutating func clearPath() {self._path = nil}

  public var duration: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _path: Frontend_Path? = nil
}

/// rpc #2 ´ÙÁß °æ·ÎÁ¶È¸ (with Á¤·ùÀåID)
public struct Frontend_FindMultiPathRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requests: [Frontend_FindPathRequest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Frontend_FindMultiPathReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var replies: [Frontend_FindPathReply] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// rpc #3 °æÀ¯Áö ¸ñ·Ï¿¡ ´ëÇÑ °æ·Î,ETA Á¶È¸
public struct Frontend_WaypointsWithSupply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ÇÊ¼ö ÀÔ·Â°ª
  public var regionCode: Int32 = 0

  public var supplyID: String = String()

  public var waypointList: [Frontend_WaypointsWithSupply.Waypoint] = []

  /// ¼±ÅÃ ÀÔ·Â°ª (ÇöÀç ¹Ì±¸Çö)
  /// ÇöÀç RoutePlanner ÀÚÃ¼ÀûÀ¸·Î Â÷·® À§Ä¡ Á¶È¸ ¹× ¸Ê¸ÅÄª ÇÏ¿© »ç¿ë.
  public var supplyLngLat: Frontend_LngLat {
    get {return _supplyLngLat ?? Frontend_LngLat()}
    set {_supplyLngLat = newValue}
  }
  /// Returns true if `supplyLngLat` has been explicitly set.
  public var hasSupplyLngLat: Bool {return self._supplyLngLat != nil}
  /// Clears the value of `supplyLngLat`. Subsequent reads from it will return its default value.
  public mutating func clearSupplyLngLat() {self._supplyLngLat = nil}

  /// ¿ÜºÎ¿¡¼­ ¸Ê¸ÅÄª½Ã ÀÔ·Â
  public var supplyNodeIdx: Int32 = 0

  /// °æÀ¯Áö µµÂøÇÏ¿© ±æ Ã£À»¶§ Â÷·®ÀÌ µµÂøÇÑ °æÀ¯Áö. ÀÌ °ªÀÌ Á¸ÀçÇÏ¸é Â÷·® À§Ä¡¸¦ ´ë½ÅÇÏ¿© ±æÃ£±â¿¡ »ç¿ëµÊ.
  public var arrivedWaypoint: Frontend_WaypointsWithSupply.Waypoint {
    get {return _arrivedWaypoint ?? Frontend_WaypointsWithSupply.Waypoint()}
    set {_arrivedWaypoint = newValue}
  }
  /// Returns true if `arrivedWaypoint` has been explicitly set.
  public var hasArrivedWaypoint: Bool {return self._arrivedWaypoint != nil}
  /// Clears the value of `arrivedWaypoint`. Subsequent reads from it will return its default value.
  public mutating func clearArrivedWaypoint() {self._arrivedWaypoint = nil}

  /// Â÷·® ÇöÀ§Ä¡¿¡¼­ Ãâ¹ßÇÒ ½Ã°¢ (default : DateTime.Now)
  public var startTimeAtCar: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTimeAtCar ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTimeAtCar = newValue}
  }
  /// Returns true if `startTimeAtCar` has been explicitly set.
  public var hasStartTimeAtCar: Bool {return self._startTimeAtCar != nil}
  /// Clears the value of `startTimeAtCar`. Subsequent reads from it will return its default value.
  public mutating func clearStartTimeAtCar() {self._startTimeAtCar = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Waypoint {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Åë½Å ¾çÃøÀÌ µ¿ÀÏÇÑ µµ·Îµ¥ÀÌÅÍ Á¤º¸¸¦ ±âÁØÀ¸·Î ÇØ¾ßÇÔ.
    public var nodeIdx: Int32 = 0

    /// °ËÅäÇÊ¿ä : RoutePlanner°¡ Á¤·ùÀå Á¤º¸¸¦ ¾Ë°í ÀÖ´Ù´Â ÀüÁ¦ÇÏ¿¡
    /// ³»ºÎÀûÀ¸·Î station_id =>node_idx·Î ¸ÅÇÎÇÏ¿© °æ·ÎÅ½»ö.
    public var stationID: String = String()

    public var stationLngLat: Frontend_LngLat {
      get {return _stationLngLat ?? Frontend_LngLat()}
      set {_stationLngLat = newValue}
    }
    /// Returns true if `stationLngLat` has been explicitly set.
    public var hasStationLngLat: Bool {return self._stationLngLat != nil}
    /// Clears the value of `stationLngLat`. Subsequent reads from it will return its default value.
    public mutating func clearStationLngLat() {self._stationLngLat = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _stationLngLat: Frontend_LngLat? = nil
  }

  public init() {}

  fileprivate var _supplyLngLat: Frontend_LngLat? = nil
  fileprivate var _arrivedWaypoint: Frontend_WaypointsWithSupply.Waypoint? = nil
  fileprivate var _startTimeAtCar: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Frontend_PathWithEtaPerWaypoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// °æ·Î [ Â÷·® -> °æÀ¯Áö 1, °æÀ¯Áö1 -> °æÀ¯Áö 2, ...]
  public var pathList: [Frontend_Path] = []

  /// ¼Ò¿ä½Ã°£(ÃÊ) [ Â÷·® -> °æÀ¯Áö 1, °æÀ¯Áö1 -> °æÀ¯Áö 2, ...]
  public var durationList: [Double] = []

  /// ¿¹Á¤µµÂø½Ã°¢ [ °æÀ¯Áö 1, °æÀ¯Áö 2, ...]
  public var etaList: [SwiftProtobuf.Google_Protobuf_Timestamp] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Frontend_Supply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///   int32 index = 1; // ÇöÀç ¿ëµµ ºÒ¸í. ±âÁ¸ listÇüÅÂ·Î ÀúÀåµÉ ¶§ÀÇ »öÀÎ.
  public var id: String = String()

  /// ³»ºÎ Dictionary Key
  public var name: String = String()

  /// int32 region = 4; // ³»ºÎ ¾ç½Ä¿¡¼­ regionCode Á¦°ÅµÇ¾úÀ½.
  /// 0 or 1. service_start, service_end
  public var state: Frontend_Supply.ServiceState = .serviceStart

  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  /// ³»ºÎ¿¡¼­´Â longitude, latitude º°µµ
  public var location: Frontend_LngLat {
    get {return _location ?? Frontend_LngLat()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {self._location = nil}

  public var routingQueueList: [Frontend_Supply.RoutingQueue] = []

  /// ID°ª
  public var routingDemandList: [String] = []

  public var routingDistanceList: [Frontend_Supply.RoutingDistance] = []

  /// Çö½ÃÁ¡ÀÇ Å¾½Â°´ ¼ö (= ³²Àº ÇÏÂ÷QueueÀÇ ¼ö)
  public var currentPassenger: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ServiceState: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case serviceStart // = 0
    case serviceEnd // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .serviceStart
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .serviceStart
      case 1: self = .serviceEnd
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .serviceStart: return 0
      case .serviceEnd: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct RoutingQueue {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var nodeIndex: Int32 = 0

    public var stationID: String = String()

    /// µ¿ÀÏ ¸µÅ©³ëµå»ó ¿©·¯ Á¤·ùÀå Á¸Àç½Ã °æÀ¯ ¼ø¼­ ÁöÁ¤.
    public var stationPriority: Int32 = 0

    public var userID: Int32 = 0

    /// ºÒº¯°ª
    public var state: Frontend_Supply.RoutingQueue.QueueState = .start

    public var demandID: String = String()

    /// ÇØ´ç demandÀÇ Å¾½ÂÀÎ¿ø
    public var demandPassenger: Int32 = 0

    /// ´ÙÀ½ Queue±îÁöÀÇ °æ·Î ÀÎµ¦½º. µ¿ÀÏ Á¤·ùÀåÀÌ°Å³ª ¸¶Áö¸· Å¥¸é -1.
    public var pathIndex: Int32 = 0

    /// °æ·ÎÀÇ ±æÀÌ [m]. ¹èÂ÷½Ã ½ÇÁúÀû ÆÇ´Ü±âÁØ.
    public var pathDistance: Double = 0

    /// ´ÙÀ½ Queue±îÁöÀÇ ¿¹»óÀÌµ¿½Ã°£ [sec]. µ¿ÀÏ Á¤·ùÀå ¶Ç´Â ¸¶Áö¸· Å¥ÀÏ½Ã 0.
    public var estimateTime: Double = 0

    /// °æÀ¯Áö ´ÜÀ§ ¹æ¹® ¼ø¼­. 0ºÎÅÍ ½ÃÀÛ.
    public var sequenceIndex: Int32 = 0

    /// ¹èÂ÷Ãë¼Ò ÇÃ·¡±× (¹Ì»ç¿ë) 
    public var cancelSegment: Bool = false

    /// ¹èÂ÷¾Ë°í¸®Áò ¿ÜºÎÀÇ ¿£Áø´Ü¿¡¼­ º°µµ Á¶È¸ÇÏ¿© Ãß°¡
    public var stationName: String = String()

    public var stationLngLat: Frontend_LngLat {
      get {return _stationLngLat ?? Frontend_LngLat()}
      set {_stationLngLat = newValue}
    }
    /// Returns true if `stationLngLat` has been explicitly set.
    public var hasStationLngLat: Bool {return self._stationLngLat != nil}
    /// Clears the value of `stationLngLat`. Subsequent reads from it will return its default value.
    public mutating func clearStationLngLat() {self._stationLngLat = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// START : Å¾½ÂÁö / END : ÇÏÂ÷Áö / CANCEL : ¹èÂ÷ Ãë¼Ò ÁöÁ¡ / RELOCATION : Àç¹èÄ¡ ÁöÁ¡ / 
    /// PREDICTION : ¼ö¿ä ¿¹Ãø ÁöÁ¡ / ROTATION : ±³´ëÁö / REST : ÈÞ°ÔÁö / GARAGE : Â÷°íÁö / REPAIR : ¼ö¸®Áö / ROUTE : °íÁ¤³ë¼±
    public enum QueueState: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// ½ÂÂ÷Áö
      case start // = 0

      /// ÇÏÂ÷Áö
      case end // = 1
      case cancel // = 2

      /// Àç¹èÄ¡
      case relocation // = 3

      /// ¼ö¿ä¿¹ÃøÀÌµ¿
      case prediction // = 4
      case rotation // = 5
      case rest // = 6
      case garage // = 7
      case repair // = 8
      case route // = 9
      case UNRECOGNIZED(Int)

      public init() {
        self = .start
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .start
        case 1: self = .end
        case 2: self = .cancel
        case 3: self = .relocation
        case 4: self = .prediction
        case 5: self = .rotation
        case 6: self = .rest
        case 7: self = .garage
        case 8: self = .repair
        case 9: self = .route
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .start: return 0
        case .end: return 1
        case .cancel: return 2
        case .relocation: return 3
        case .prediction: return 4
        case .rotation: return 5
        case .rest: return 6
        case .garage: return 7
        case .repair: return 8
        case .route: return 9
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    fileprivate var _stationLngLat: Frontend_LngLat? = nil
  }

  public struct RoutingDistance {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var demandID: String = String()

    public var userID: Int32 = 0

    public var state: Int32 = 0

    /// ¹èÂ÷ ½ÃÁ¡¿¡¼­ Â÷·®ÀÇ ³ëµå (ÃÖÃÊ ºÎ¿© ÈÄ ºÒº¯)
    public var demandNode: Int32 = 0

    /// °¡º¯. ¸Å ¹èÂ÷¸¶´Ù °»½Å
    public var recentNode: Int32 = 0

    /// ÃÖÃÊ ¹èÂ÷½Ã ´ë±â°Å¸®
    public var initWaitDistance: Double = 0

    /// ÃÖÃÊ ¹èÂ÷½Ã ¿îÇà°Å¸®
    public var initRaceDistance: Double = 0

    /// °¡º¯. ¸Å ¹èÂ÷¸¶´Ù °»½Å
    public var diffWaitDistance: Double = 0

    /// °¡º¯.
    public var diffRaceDistance: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _location: Frontend_LngLat? = nil
}

#if swift(>=4.2)

extension Frontend_Supply.ServiceState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Frontend_Supply.ServiceState] = [
    .serviceStart,
    .serviceEnd,
  ]
}

extension Frontend_Supply.RoutingQueue.QueueState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Frontend_Supply.RoutingQueue.QueueState] = [
    .start,
    .end,
    .cancel,
    .relocation,
    .prediction,
    .rotation,
    .rest,
    .garage,
    .repair,
    .route,
  ]
}

#endif  // swift(>=4.2)

public struct Frontend_TripPlannerResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var returnCode: Int32 = 0

  public var resultMessage: String = String()

  public var data: [Frontend_Trip] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Frontend_Trip {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: String = String()

  public var totalPrice: Int32 = 0

  public var transferCount: Int32 = 0

  public var totalDistance: Int32 = 0

  public var totalTime: Int32 = 0

  public var aboardTime: Int32 = 0

  public var aboardDistance: Int32 = 0

  public var walkTime: Int32 = 0

  public var walkDistance: Int32 = 0

  public var pickupStopIdx: Int32 = 0

  public var dropoffStopIdx: Int32 = 0

  public var waypoints: [Frontend_Waypoint] = []

  public var paths: [Frontend_Path] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Frontend_Waypoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var seq: Int32 = 0

  public var type: String = String()

  public var lng: Double = 0

  public var lat: Double = 0

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Frontend_LngLat {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lng: Double = 0

  public var lat: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Frontend_DemandWaypointType: @unchecked Sendable {}
extension Frontend_UserStateRequest: @unchecked Sendable {}
extension Frontend_UserStateResponse: @unchecked Sendable {}
extension Frontend_UserStateWithInfo: @unchecked Sendable {}
extension Frontend_GetSupplyLocationRequest: @unchecked Sendable {}
extension Frontend_SupplyStateResponse: @unchecked Sendable {}
extension Frontend_SupplyLocationRequest: @unchecked Sendable {}
extension Frontend_SupplyLocationResponse: @unchecked Sendable {}
extension Frontend_FrontEndDispatchRequest: @unchecked Sendable {}
extension Frontend_FrontEndDispatchResponse: @unchecked Sendable {}
extension Frontend_VehicleInfo: @unchecked Sendable {}
extension Frontend_DemandWaypoint: @unchecked Sendable {}
extension Frontend_SetDispatchCancelRequest: @unchecked Sendable {}
extension Frontend_SetArrivalWaypointRequest: @unchecked Sendable {}
extension Frontend_Path: @unchecked Sendable {}
extension Frontend_Link: @unchecked Sendable {}
extension Frontend_Loc: @unchecked Sendable {}
extension Frontend_UserState: @unchecked Sendable {}
extension Frontend_SupplyState: @unchecked Sendable {}
extension Frontend_SupplyLocation: @unchecked Sendable {}
extension Frontend_SupplyLocationMatched: @unchecked Sendable {}
extension Frontend_SupplyLocationMatched.Matched: @unchecked Sendable {}
extension Frontend_SupplyWaypoints: @unchecked Sendable {}
extension Frontend_SupplyWaypointUpdate: @unchecked Sendable {}
extension Frontend_SupplyWaypointUpdate.OneOf_ActionDetail: @unchecked Sendable {}
extension Frontend_SupplyWaypointUpdate.WaypointActionType: @unchecked Sendable {}
extension Frontend_SupplyWaypointUpdate.DispatchDetail: @unchecked Sendable {}
extension Frontend_SupplyWaypointUpdate.ArrivalDetail: @unchecked Sendable {}
extension Frontend_SupplyWaypointUpdate.CancelDetail: @unchecked Sendable {}
extension Frontend_SupplyWaypointUpdate.DemandStationInfoFromPrev: @unchecked Sendable {}
extension Frontend_SupplyWaypoint: @unchecked Sendable {}
extension Frontend_SupplyWaypoint.SupplyWaypointType: @unchecked Sendable {}
extension Frontend_SupplyWaypointPaths: @unchecked Sendable {}
extension Frontend_SupplyWaypointPathUpdate: @unchecked Sendable {}
extension Frontend_SupplyWaypointPathUpdate.PathActionType: @unchecked Sendable {}
extension Frontend_SupplyWaypointPath: @unchecked Sendable {}
extension Frontend_SupplyWaypointEtas: @unchecked Sendable {}
extension Frontend_SupplyWaypointEtaUpdate: @unchecked Sendable {}
extension Frontend_SupplyWaypointEtaUpdate.EtaActionType: @unchecked Sendable {}
extension Frontend_SupplyWaypointEta: @unchecked Sendable {}
extension Frontend_FindPathRequest: @unchecked Sendable {}
extension Frontend_FindPathReply: @unchecked Sendable {}
extension Frontend_FindMultiPathRequest: @unchecked Sendable {}
extension Frontend_FindMultiPathReply: @unchecked Sendable {}
extension Frontend_WaypointsWithSupply: @unchecked Sendable {}
extension Frontend_WaypointsWithSupply.Waypoint: @unchecked Sendable {}
extension Frontend_PathWithEtaPerWaypoint: @unchecked Sendable {}
extension Frontend_Supply: @unchecked Sendable {}
extension Frontend_Supply.ServiceState: @unchecked Sendable {}
extension Frontend_Supply.RoutingQueue: @unchecked Sendable {}
extension Frontend_Supply.RoutingQueue.QueueState: @unchecked Sendable {}
extension Frontend_Supply.RoutingDistance: @unchecked Sendable {}
extension Frontend_TripPlannerResult: @unchecked Sendable {}
extension Frontend_Trip: @unchecked Sendable {}
extension Frontend_Waypoint: @unchecked Sendable {}
extension Frontend_LngLat: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "frontend"

extension Frontend_DemandWaypointType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PICK_UP_POINT"),
    1: .same(proto: "DROP_OFF_POINT"),
    2: .same(proto: "WAYPOINT"),
    3: .same(proto: "DEPARTURE_POINT"),
    4: .same(proto: "ARRIVAL_POINT"),
  ]
}

extension Frontend_UserStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserStateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UserIdx"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userIdx) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userIdx != 0 {
      try visitor.visitSingularInt32Field(value: self.userIdx, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_UserStateRequest, rhs: Frontend_UserStateRequest) -> Bool {
    if lhs.userIdx != rhs.userIdx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_UserStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserStateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_state_with_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.userStateWithInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userStateWithInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userStateWithInfo, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_UserStateResponse, rhs: Frontend_UserStateResponse) -> Bool {
    if lhs.userStateWithInfo != rhs.userStateWithInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_UserStateWithInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserStateWithInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_state"),
    6: .standard(proto: "vehicle_info"),
    7: .standard(proto: "from_lng_lat"),
    8: .standard(proto: "from_walk_path"),
    9: .standard(proto: "to_lng_lat"),
    10: .standard(proto: "to_walk_path"),
    11: .standard(proto: "item_detail"),
    12: .standard(proto: "pick_up_eta"),
    13: .standard(proto: "drop_off_eta"),
    14: .standard(proto: "supply_waypoint_list"),
    15: .standard(proto: "supply_waypoint_path_list"),
    16: .standard(proto: "pick_up_path_seq"),
    17: .standard(proto: "drop_off_path_seq"),
    18: .standard(proto: "supply_waypoint_version"),
    19: .standard(proto: "supply_waypoint_eta_version"),
    20: .standard(proto: "supply_waypoint_path_version"),
  ]

  fileprivate class _StorageClass {
    var _userState: Frontend_UserState? = nil
    var _vehicleInfo: Frontend_VehicleInfo? = nil
    var _fromLngLat: Frontend_LngLat? = nil
    var _fromWalkPath: Frontend_Path? = nil
    var _toLngLat: Frontend_LngLat? = nil
    var _toWalkPath: Frontend_Path? = nil
    var _itemDetail: String = String()
    var _pickUpEta: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _dropOffEta: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _supplyWaypointList: [Frontend_SupplyWaypoint] = []
    var _supplyWaypointPathList: [Frontend_Path] = []
    var _pickUpPathSeq: Int32 = 0
    var _dropOffPathSeq: Int32 = 0
    var _supplyWaypointVersion: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _supplyWaypointEtaVersion: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _supplyWaypointPathVersion: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _userState = source._userState
      _vehicleInfo = source._vehicleInfo
      _fromLngLat = source._fromLngLat
      _fromWalkPath = source._fromWalkPath
      _toLngLat = source._toLngLat
      _toWalkPath = source._toWalkPath
      _itemDetail = source._itemDetail
      _pickUpEta = source._pickUpEta
      _dropOffEta = source._dropOffEta
      _supplyWaypointList = source._supplyWaypointList
      _supplyWaypointPathList = source._supplyWaypointPathList
      _pickUpPathSeq = source._pickUpPathSeq
      _dropOffPathSeq = source._dropOffPathSeq
      _supplyWaypointVersion = source._supplyWaypointVersion
      _supplyWaypointEtaVersion = source._supplyWaypointEtaVersion
      _supplyWaypointPathVersion = source._supplyWaypointPathVersion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._userState) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._vehicleInfo) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._fromLngLat) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._fromWalkPath) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._toLngLat) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._toWalkPath) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._itemDetail) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._pickUpEta) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._dropOffEta) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._supplyWaypointList) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._supplyWaypointPathList) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._pickUpPathSeq) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._dropOffPathSeq) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._supplyWaypointVersion) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._supplyWaypointEtaVersion) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._supplyWaypointPathVersion) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._userState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._vehicleInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._fromLngLat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._fromWalkPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._toLngLat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._toWalkPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._itemDetail.isEmpty {
        try visitor.visitSingularStringField(value: _storage._itemDetail, fieldNumber: 11)
      }
      try { if let v = _storage._pickUpEta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._dropOffEta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._supplyWaypointList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._supplyWaypointList, fieldNumber: 14)
      }
      if !_storage._supplyWaypointPathList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._supplyWaypointPathList, fieldNumber: 15)
      }
      if _storage._pickUpPathSeq != 0 {
        try visitor.visitSingularInt32Field(value: _storage._pickUpPathSeq, fieldNumber: 16)
      }
      if _storage._dropOffPathSeq != 0 {
        try visitor.visitSingularInt32Field(value: _storage._dropOffPathSeq, fieldNumber: 17)
      }
      try { if let v = _storage._supplyWaypointVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._supplyWaypointEtaVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._supplyWaypointPathVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_UserStateWithInfo, rhs: Frontend_UserStateWithInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._userState != rhs_storage._userState {return false}
        if _storage._vehicleInfo != rhs_storage._vehicleInfo {return false}
        if _storage._fromLngLat != rhs_storage._fromLngLat {return false}
        if _storage._fromWalkPath != rhs_storage._fromWalkPath {return false}
        if _storage._toLngLat != rhs_storage._toLngLat {return false}
        if _storage._toWalkPath != rhs_storage._toWalkPath {return false}
        if _storage._itemDetail != rhs_storage._itemDetail {return false}
        if _storage._pickUpEta != rhs_storage._pickUpEta {return false}
        if _storage._dropOffEta != rhs_storage._dropOffEta {return false}
        if _storage._supplyWaypointList != rhs_storage._supplyWaypointList {return false}
        if _storage._supplyWaypointPathList != rhs_storage._supplyWaypointPathList {return false}
        if _storage._pickUpPathSeq != rhs_storage._pickUpPathSeq {return false}
        if _storage._dropOffPathSeq != rhs_storage._dropOffPathSeq {return false}
        if _storage._supplyWaypointVersion != rhs_storage._supplyWaypointVersion {return false}
        if _storage._supplyWaypointEtaVersion != rhs_storage._supplyWaypointEtaVersion {return false}
        if _storage._supplyWaypointPathVersion != rhs_storage._supplyWaypointPathVersion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_GetSupplyLocationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSupplyLocationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "supply_idx"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.supplyIdx) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.supplyIdx != 0 {
      try visitor.visitSingularInt32Field(value: self.supplyIdx, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_GetSupplyLocationRequest, rhs: Frontend_GetSupplyLocationRequest) -> Bool {
    if lhs.supplyIdx != rhs.supplyIdx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_SupplyStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SupplyStateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "supply_state"),
    2: .standard(proto: "supply_waypoint_list"),
    3: .standard(proto: "supply_waypoint_eta_list"),
    4: .standard(proto: "supply_waypoint_path_list"),
    5: .standard(proto: "supply_waypoint_version"),
    6: .standard(proto: "supply_waypoint_eta_version"),
    7: .standard(proto: "supply_waypoint_path_version"),
    8: .standard(proto: "recent_stop_idx"),
    9: .standard(proto: "visit_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.supplyState) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.supplyWaypointList) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.supplyWaypointEtaList) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.supplyWaypointPathList) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._supplyWaypointVersion) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._supplyWaypointEtaVersion) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._supplyWaypointPathVersion) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.recentStopIdx) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.visitType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.supplyState.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.supplyState, fieldNumber: 1)
    }
    if !self.supplyWaypointList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.supplyWaypointList, fieldNumber: 2)
    }
    if !self.supplyWaypointEtaList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.supplyWaypointEtaList, fieldNumber: 3)
    }
    if !self.supplyWaypointPathList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.supplyWaypointPathList, fieldNumber: 4)
    }
    try { if let v = self._supplyWaypointVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._supplyWaypointEtaVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._supplyWaypointPathVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.recentStopIdx != 0 {
      try visitor.visitSingularInt32Field(value: self.recentStopIdx, fieldNumber: 8)
    }
    if self.visitType != 0 {
      try visitor.visitSingularInt32Field(value: self.visitType, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_SupplyStateResponse, rhs: Frontend_SupplyStateResponse) -> Bool {
    if lhs.supplyState != rhs.supplyState {return false}
    if lhs.supplyWaypointList != rhs.supplyWaypointList {return false}
    if lhs.supplyWaypointEtaList != rhs.supplyWaypointEtaList {return false}
    if lhs.supplyWaypointPathList != rhs.supplyWaypointPathList {return false}
    if lhs._supplyWaypointVersion != rhs._supplyWaypointVersion {return false}
    if lhs._supplyWaypointEtaVersion != rhs._supplyWaypointEtaVersion {return false}
    if lhs._supplyWaypointPathVersion != rhs._supplyWaypointPathVersion {return false}
    if lhs.recentStopIdx != rhs.recentStopIdx {return false}
    if lhs.visitType != rhs.visitType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_SupplyLocationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SupplyLocationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "loc"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._loc) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._loc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_SupplyLocationRequest, rhs: Frontend_SupplyLocationRequest) -> Bool {
    if lhs._loc != rhs._loc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_SupplyLocationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SupplyLocationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "supply_locationMatched"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._supplyLocationMatched) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._supplyLocationMatched {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_SupplyLocationResponse, rhs: Frontend_SupplyLocationResponse) -> Bool {
    if lhs._supplyLocationMatched != rhs._supplyLocationMatched {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_FrontEndDispatchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FrontEndDispatchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_idx"),
    2: .standard(proto: "region_code"),
    3: .standard(proto: "item_count"),
    4: .standard(proto: "item_type"),
    5: .standard(proto: "item_detail"),
    6: .standard(proto: "demand_type"),
    7: .standard(proto: "pick_up_stop_idx"),
    8: .standard(proto: "drop_off_stop_idx"),
    9: .standard(proto: "from_walk_path"),
    10: .standard(proto: "to_walk_path"),
    11: .standard(proto: "from_lng_lat"),
    12: .standard(proto: "from_poi"),
    13: .standard(proto: "to_lng_lat"),
    14: .standard(proto: "to_poi"),
    15: .standard(proto: "pick_up_lng_lat"),
    16: .standard(proto: "pick_up_poi"),
    17: .standard(proto: "drop_off_lng_lat"),
    18: .standard(proto: "drop_off_poi"),
  ]

  fileprivate class _StorageClass {
    var _userIdx: Int32 = 0
    var _regionCode: Int32 = 0
    var _itemCount: Int32 = 0
    var _itemType: String = String()
    var _itemDetail: String = String()
    var _demandType: String = String()
    var _pickUpStopIdx: Int32 = 0
    var _dropOffStopIdx: Int32 = 0
    var _fromWalkPath: String = String()
    var _toWalkPath: String = String()
    var _fromLngLat: Frontend_LngLat? = nil
    var _fromPoi: String = String()
    var _toLngLat: Frontend_LngLat? = nil
    var _toPoi: String = String()
    var _pickUpLngLat: Frontend_LngLat? = nil
    var _pickUpPoi: String = String()
    var _dropOffLngLat: Frontend_LngLat? = nil
    var _dropOffPoi: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _userIdx = source._userIdx
      _regionCode = source._regionCode
      _itemCount = source._itemCount
      _itemType = source._itemType
      _itemDetail = source._itemDetail
      _demandType = source._demandType
      _pickUpStopIdx = source._pickUpStopIdx
      _dropOffStopIdx = source._dropOffStopIdx
      _fromWalkPath = source._fromWalkPath
      _toWalkPath = source._toWalkPath
      _fromLngLat = source._fromLngLat
      _fromPoi = source._fromPoi
      _toLngLat = source._toLngLat
      _toPoi = source._toPoi
      _pickUpLngLat = source._pickUpLngLat
      _pickUpPoi = source._pickUpPoi
      _dropOffLngLat = source._dropOffLngLat
      _dropOffPoi = source._dropOffPoi
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._userIdx) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._regionCode) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._itemCount) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._itemType) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._itemDetail) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._demandType) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._pickUpStopIdx) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._dropOffStopIdx) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._fromWalkPath) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._toWalkPath) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._fromLngLat) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._fromPoi) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._toLngLat) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._toPoi) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._pickUpLngLat) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._pickUpPoi) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._dropOffLngLat) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._dropOffPoi) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._userIdx != 0 {
        try visitor.visitSingularInt32Field(value: _storage._userIdx, fieldNumber: 1)
      }
      if _storage._regionCode != 0 {
        try visitor.visitSingularInt32Field(value: _storage._regionCode, fieldNumber: 2)
      }
      if _storage._itemCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._itemCount, fieldNumber: 3)
      }
      if !_storage._itemType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._itemType, fieldNumber: 4)
      }
      if !_storage._itemDetail.isEmpty {
        try visitor.visitSingularStringField(value: _storage._itemDetail, fieldNumber: 5)
      }
      if !_storage._demandType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._demandType, fieldNumber: 6)
      }
      if _storage._pickUpStopIdx != 0 {
        try visitor.visitSingularInt32Field(value: _storage._pickUpStopIdx, fieldNumber: 7)
      }
      if _storage._dropOffStopIdx != 0 {
        try visitor.visitSingularInt32Field(value: _storage._dropOffStopIdx, fieldNumber: 8)
      }
      if !_storage._fromWalkPath.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fromWalkPath, fieldNumber: 9)
      }
      if !_storage._toWalkPath.isEmpty {
        try visitor.visitSingularStringField(value: _storage._toWalkPath, fieldNumber: 10)
      }
      try { if let v = _storage._fromLngLat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._fromPoi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fromPoi, fieldNumber: 12)
      }
      try { if let v = _storage._toLngLat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._toPoi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._toPoi, fieldNumber: 14)
      }
      try { if let v = _storage._pickUpLngLat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if !_storage._pickUpPoi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pickUpPoi, fieldNumber: 16)
      }
      try { if let v = _storage._dropOffLngLat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if !_storage._dropOffPoi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._dropOffPoi, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_FrontEndDispatchRequest, rhs: Frontend_FrontEndDispatchRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._userIdx != rhs_storage._userIdx {return false}
        if _storage._regionCode != rhs_storage._regionCode {return false}
        if _storage._itemCount != rhs_storage._itemCount {return false}
        if _storage._itemType != rhs_storage._itemType {return false}
        if _storage._itemDetail != rhs_storage._itemDetail {return false}
        if _storage._demandType != rhs_storage._demandType {return false}
        if _storage._pickUpStopIdx != rhs_storage._pickUpStopIdx {return false}
        if _storage._dropOffStopIdx != rhs_storage._dropOffStopIdx {return false}
        if _storage._fromWalkPath != rhs_storage._fromWalkPath {return false}
        if _storage._toWalkPath != rhs_storage._toWalkPath {return false}
        if _storage._fromLngLat != rhs_storage._fromLngLat {return false}
        if _storage._fromPoi != rhs_storage._fromPoi {return false}
        if _storage._toLngLat != rhs_storage._toLngLat {return false}
        if _storage._toPoi != rhs_storage._toPoi {return false}
        if _storage._pickUpLngLat != rhs_storage._pickUpLngLat {return false}
        if _storage._pickUpPoi != rhs_storage._pickUpPoi {return false}
        if _storage._dropOffLngLat != rhs_storage._dropOffLngLat {return false}
        if _storage._dropOffPoi != rhs_storage._dropOffPoi {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_FrontEndDispatchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FrontEndDispatchResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_success"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isSuccess) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isSuccess != false {
      try visitor.visitSingularBoolField(value: self.isSuccess, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_FrontEndDispatchResponse, rhs: Frontend_FrontEndDispatchResponse) -> Bool {
    if lhs.isSuccess != rhs.isSuccess {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_VehicleInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VehicleInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "supply_id"),
    2: .standard(proto: "supply_loc"),
    3: .same(proto: "direction"),
    4: .same(proto: "speed"),
    5: .standard(proto: "supply_name"),
    6: .standard(proto: "number_plate"),
    7: .standard(proto: "driver_name"),
    8: .standard(proto: "drvier_image_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.supplyID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._supplyLoc) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.direction) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.speed) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.supplyName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.numberPlate) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.driverName) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.drvierImageURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.supplyID != 0 {
      try visitor.visitSingularInt32Field(value: self.supplyID, fieldNumber: 1)
    }
    try { if let v = self._supplyLoc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.direction != 0 {
      try visitor.visitSingularFloatField(value: self.direction, fieldNumber: 3)
    }
    if self.speed != 0 {
      try visitor.visitSingularFloatField(value: self.speed, fieldNumber: 4)
    }
    if !self.supplyName.isEmpty {
      try visitor.visitSingularStringField(value: self.supplyName, fieldNumber: 5)
    }
    if !self.numberPlate.isEmpty {
      try visitor.visitSingularStringField(value: self.numberPlate, fieldNumber: 6)
    }
    if !self.driverName.isEmpty {
      try visitor.visitSingularStringField(value: self.driverName, fieldNumber: 7)
    }
    if !self.drvierImageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.drvierImageURL, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_VehicleInfo, rhs: Frontend_VehicleInfo) -> Bool {
    if lhs.supplyID != rhs.supplyID {return false}
    if lhs._supplyLoc != rhs._supplyLoc {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.speed != rhs.speed {return false}
    if lhs.supplyName != rhs.supplyName {return false}
    if lhs.numberPlate != rhs.numberPlate {return false}
    if lhs.driverName != rhs.driverName {return false}
    if lhs.drvierImageURL != rhs.drvierImageURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_DemandWaypoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DemandWaypoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seq"),
    2: .standard(proto: "stop_idx"),
    3: .same(proto: "name"),
    4: .standard(proto: "waypoint_lng_lat"),
    5: .standard(proto: "waypoint_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.seq) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.stopIdx) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._waypointLngLat) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.waypointType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.seq != 0 {
      try visitor.visitSingularInt32Field(value: self.seq, fieldNumber: 1)
    }
    if self.stopIdx != 0 {
      try visitor.visitSingularInt32Field(value: self.stopIdx, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try { if let v = self._waypointLngLat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.waypointType != .pickUpPoint {
      try visitor.visitSingularEnumField(value: self.waypointType, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_DemandWaypoint, rhs: Frontend_DemandWaypoint) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs.stopIdx != rhs.stopIdx {return false}
    if lhs.name != rhs.name {return false}
    if lhs._waypointLngLat != rhs._waypointLngLat {return false}
    if lhs.waypointType != rhs.waypointType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_SetDispatchCancelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetDispatchCancelRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_idx"),
    2: .standard(proto: "region_code"),
    3: .standard(proto: "demand_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userIdx) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.regionCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.demandID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userIdx != 0 {
      try visitor.visitSingularInt32Field(value: self.userIdx, fieldNumber: 1)
    }
    if self.regionCode != 0 {
      try visitor.visitSingularInt32Field(value: self.regionCode, fieldNumber: 2)
    }
    if !self.demandID.isEmpty {
      try visitor.visitSingularStringField(value: self.demandID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_SetDispatchCancelRequest, rhs: Frontend_SetDispatchCancelRequest) -> Bool {
    if lhs.userIdx != rhs.userIdx {return false}
    if lhs.regionCode != rhs.regionCode {return false}
    if lhs.demandID != rhs.demandID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_SetArrivalWaypointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetArrivalWaypointRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "supply_idx"),
    2: .standard(proto: "stop_idx"),
    3: .standard(proto: "region_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.supplyIdx) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.stopIdx) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.regionCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.supplyIdx != 0 {
      try visitor.visitSingularInt32Field(value: self.supplyIdx, fieldNumber: 1)
    }
    if self.stopIdx != 0 {
      try visitor.visitSingularInt32Field(value: self.stopIdx, fieldNumber: 2)
    }
    if self.regionCode != 0 {
      try visitor.visitSingularInt32Field(value: self.regionCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_SetArrivalWaypointRequest, rhs: Frontend_SetArrivalWaypointRequest) -> Bool {
    if lhs.supplyIdx != rhs.supplyIdx {return false}
    if lhs.stopIdx != rhs.stopIdx {return false}
    if lhs.regionCode != rhs.regionCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_Path: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Path"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "links"),
    2: .same(proto: "dist"),
    3: .same(proto: "duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.links) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.dist) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.duration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 1)
    }
    if self.dist != 0 {
      try visitor.visitSingularDoubleField(value: self.dist, fieldNumber: 2)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_Path, rhs: Frontend_Path) -> Bool {
    if lhs.links != rhs.links {return false}
    if lhs.dist != rhs.dist {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_Link: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Link"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "length"),
    3: .same(proto: "duration"),
    4: .same(proto: "lnglats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.length) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.duration) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.lnglats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.length != 0 {
      try visitor.visitSingularDoubleField(value: self.length, fieldNumber: 2)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 3)
    }
    if !self.lnglats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lnglats, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_Link, rhs: Frontend_Link) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.length != rhs.length {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.lnglats != rhs.lnglats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_Loc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Loc"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lnglat"),
    2: .same(proto: "accuracy"),
    3: .same(proto: "heading"),
    4: .same(proto: "speed"),
    5: .standard(proto: "get_date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lnglat) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.accuracy) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.heading) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.speed) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.getDate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lnglat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.accuracy != 0 {
      try visitor.visitSingularFloatField(value: self.accuracy, fieldNumber: 2)
    }
    if self.heading != 0 {
      try visitor.visitSingularFloatField(value: self.heading, fieldNumber: 3)
    }
    if self.speed != 0 {
      try visitor.visitSingularFloatField(value: self.speed, fieldNumber: 4)
    }
    if !self.getDate.isEmpty {
      try visitor.visitSingularStringField(value: self.getDate, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_Loc, rhs: Frontend_Loc) -> Bool {
    if lhs._lnglat != rhs._lnglat {return false}
    if lhs.accuracy != rhs.accuracy {return false}
    if lhs.heading != rhs.heading {return false}
    if lhs.speed != rhs.speed {return false}
    if lhs.getDate != rhs.getDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_UserState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_idx"),
    2: .same(proto: "state"),
    3: .standard(proto: "supply_idx"),
    4: .standard(proto: "demand_id"),
    5: .standard(proto: "enqueue_event_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userIdx) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.state) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.supplyIdx) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.demandID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.enqueueEventTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userIdx != 0 {
      try visitor.visitSingularInt32Field(value: self.userIdx, fieldNumber: 1)
    }
    if self.state != 0 {
      try visitor.visitSingularInt32Field(value: self.state, fieldNumber: 2)
    }
    if self.supplyIdx != 0 {
      try visitor.visitSingularInt32Field(value: self.supplyIdx, fieldNumber: 3)
    }
    if !self.demandID.isEmpty {
      try visitor.visitSingularStringField(value: self.demandID, fieldNumber: 4)
    }
    if !self.enqueueEventTime.isEmpty {
      try visitor.visitSingularStringField(value: self.enqueueEventTime, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_UserState, rhs: Frontend_UserState) -> Bool {
    if lhs.userIdx != rhs.userIdx {return false}
    if lhs.state != rhs.state {return false}
    if lhs.supplyIdx != rhs.supplyIdx {return false}
    if lhs.demandID != rhs.demandID {return false}
    if lhs.enqueueEventTime != rhs.enqueueEventTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_SupplyState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SupplyState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "supply_idx"),
    2: .same(proto: "state"),
    3: .standard(proto: "enqueue_event_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.supplyIdx) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.state) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.enqueueEventTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.supplyIdx != 0 {
      try visitor.visitSingularInt32Field(value: self.supplyIdx, fieldNumber: 1)
    }
    if self.state != 0 {
      try visitor.visitSingularInt32Field(value: self.state, fieldNumber: 2)
    }
    if !self.enqueueEventTime.isEmpty {
      try visitor.visitSingularStringField(value: self.enqueueEventTime, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_SupplyState, rhs: Frontend_SupplyState) -> Bool {
    if lhs.supplyIdx != rhs.supplyIdx {return false}
    if lhs.state != rhs.state {return false}
    if lhs.enqueueEventTime != rhs.enqueueEventTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_SupplyLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SupplyLocation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "supply_idx"),
    2: .standard(proto: "device_id"),
    3: .same(proto: "loc"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.supplyIdx) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._loc) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.supplyIdx != 0 {
      try visitor.visitSingularInt32Field(value: self.supplyIdx, fieldNumber: 1)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 2)
    }
    try { if let v = self._loc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_SupplyLocation, rhs: Frontend_SupplyLocation) -> Bool {
    if lhs.supplyIdx != rhs.supplyIdx {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs._loc != rhs._loc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_SupplyLocationMatched: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SupplyLocationMatched"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "supply_id"),
    2: .standard(proto: "raw_lng_lat"),
    3: .standard(proto: "path_version"),
    4: .standard(proto: "match_result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.supplyID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rawLngLat) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pathVersion) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._matchResult) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.supplyID != 0 {
      try visitor.visitSingularInt32Field(value: self.supplyID, fieldNumber: 1)
    }
    try { if let v = self._rawLngLat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._pathVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._matchResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_SupplyLocationMatched, rhs: Frontend_SupplyLocationMatched) -> Bool {
    if lhs.supplyID != rhs.supplyID {return false}
    if lhs._rawLngLat != rhs._rawLngLat {return false}
    if lhs._pathVersion != rhs._pathVersion {return false}
    if lhs._matchResult != rhs._matchResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_SupplyLocationMatched.Matched: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Frontend_SupplyLocationMatched.protoMessageName + ".Matched"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_index"),
    2: .standard(proto: "link_index"),
    3: .standard(proto: "lng_lat_index"),
    4: .standard(proto: "adjusted_lng_lat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pathIndex) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.linkIndex) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.lngLatIndex) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._adjustedLngLat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.pathIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.pathIndex, fieldNumber: 1)
    }
    if self.linkIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.linkIndex, fieldNumber: 2)
    }
    if self.lngLatIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.lngLatIndex, fieldNumber: 3)
    }
    try { if let v = self._adjustedLngLat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_SupplyLocationMatched.Matched, rhs: Frontend_SupplyLocationMatched.Matched) -> Bool {
    if lhs.pathIndex != rhs.pathIndex {return false}
    if lhs.linkIndex != rhs.linkIndex {return false}
    if lhs.lngLatIndex != rhs.lngLatIndex {return false}
    if lhs._adjustedLngLat != rhs._adjustedLngLat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_SupplyWaypoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SupplyWaypoints"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "supply_waypoint"),
    2: .standard(proto: "get_date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.supplyWaypoint) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._getDate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.supplyWaypoint.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.supplyWaypoint, fieldNumber: 1)
    }
    try { if let v = self._getDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_SupplyWaypoints, rhs: Frontend_SupplyWaypoints) -> Bool {
    if lhs.supplyWaypoint != rhs.supplyWaypoint {return false}
    if lhs._getDate != rhs._getDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_SupplyWaypointUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SupplyWaypointUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "supply_id"),
    2: .standard(proto: "waypoint_version"),
    3: .same(proto: "action"),
    4: .standard(proto: "dispatch_detail"),
    5: .standard(proto: "arrival_detail"),
    6: .standard(proto: "cancel_detail"),
    7: .standard(proto: "supply_waypoint_list"),
  ]

  fileprivate class _StorageClass {
    var _supplyID: Int32 = 0
    var _waypointVersion: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _action: Frontend_SupplyWaypointUpdate.WaypointActionType = .dispatch
    var _actionDetail: Frontend_SupplyWaypointUpdate.OneOf_ActionDetail?
    var _supplyWaypointList: [Frontend_SupplyWaypoint] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _supplyID = source._supplyID
      _waypointVersion = source._waypointVersion
      _action = source._action
      _actionDetail = source._actionDetail
      _supplyWaypointList = source._supplyWaypointList
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._supplyID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._waypointVersion) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._action) }()
        case 4: try {
          var v: Frontend_SupplyWaypointUpdate.DispatchDetail?
          var hadOneofValue = false
          if let current = _storage._actionDetail {
            hadOneofValue = true
            if case .dispatchDetail(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionDetail = .dispatchDetail(v)
          }
        }()
        case 5: try {
          var v: Frontend_SupplyWaypointUpdate.ArrivalDetail?
          var hadOneofValue = false
          if let current = _storage._actionDetail {
            hadOneofValue = true
            if case .arrivalDetail(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionDetail = .arrivalDetail(v)
          }
        }()
        case 6: try {
          var v: Frontend_SupplyWaypointUpdate.CancelDetail?
          var hadOneofValue = false
          if let current = _storage._actionDetail {
            hadOneofValue = true
            if case .cancelDetail(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionDetail = .cancelDetail(v)
          }
        }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._supplyWaypointList) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._supplyID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._supplyID, fieldNumber: 1)
      }
      try { if let v = _storage._waypointVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._action != .dispatch {
        try visitor.visitSingularEnumField(value: _storage._action, fieldNumber: 3)
      }
      switch _storage._actionDetail {
      case .dispatchDetail?: try {
        guard case .dispatchDetail(let v)? = _storage._actionDetail else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .arrivalDetail?: try {
        guard case .arrivalDetail(let v)? = _storage._actionDetail else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .cancelDetail?: try {
        guard case .cancelDetail(let v)? = _storage._actionDetail else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case nil: break
      }
      if !_storage._supplyWaypointList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._supplyWaypointList, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_SupplyWaypointUpdate, rhs: Frontend_SupplyWaypointUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._supplyID != rhs_storage._supplyID {return false}
        if _storage._waypointVersion != rhs_storage._waypointVersion {return false}
        if _storage._action != rhs_storage._action {return false}
        if _storage._actionDetail != rhs_storage._actionDetail {return false}
        if _storage._supplyWaypointList != rhs_storage._supplyWaypointList {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_SupplyWaypointUpdate.WaypointActionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISPATCH"),
    1: .same(proto: "ARRIVAL"),
    2: .same(proto: "CANCEL"),
  ]
}

extension Frontend_SupplyWaypointUpdate.DispatchDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Frontend_SupplyWaypointUpdate.protoMessageName + ".DispatchDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "demand_id"),
    2: .standard(proto: "pick_waypoint_sequence"),
    3: .standard(proto: "drop_waypoint_sequence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.demandID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pickWaypointSequence) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.dropWaypointSequence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.demandID.isEmpty {
      try visitor.visitSingularStringField(value: self.demandID, fieldNumber: 1)
    }
    if self.pickWaypointSequence != 0 {
      try visitor.visitSingularInt32Field(value: self.pickWaypointSequence, fieldNumber: 2)
    }
    if self.dropWaypointSequence != 0 {
      try visitor.visitSingularInt32Field(value: self.dropWaypointSequence, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_SupplyWaypointUpdate.DispatchDetail, rhs: Frontend_SupplyWaypointUpdate.DispatchDetail) -> Bool {
    if lhs.demandID != rhs.demandID {return false}
    if lhs.pickWaypointSequence != rhs.pickWaypointSequence {return false}
    if lhs.dropWaypointSequence != rhs.dropWaypointSequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_SupplyWaypointUpdate.ArrivalDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Frontend_SupplyWaypointUpdate.protoMessageName + ".ArrivalDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "removed_waypoint"),
    2: .standard(proto: "noshow_dropinfo_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._removedWaypoint) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.noshowDropinfoList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._removedWaypoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.noshowDropinfoList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.noshowDropinfoList, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_SupplyWaypointUpdate.ArrivalDetail, rhs: Frontend_SupplyWaypointUpdate.ArrivalDetail) -> Bool {
    if lhs._removedWaypoint != rhs._removedWaypoint {return false}
    if lhs.noshowDropinfoList != rhs.noshowDropinfoList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_SupplyWaypointUpdate.CancelDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Frontend_SupplyWaypointUpdate.protoMessageName + ".CancelDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "demand_id"),
    2: .standard(proto: "canceled_info_pick"),
    3: .standard(proto: "canceled_info_drop"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.demandID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._canceledInfoPick) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._canceledInfoDrop) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.demandID.isEmpty {
      try visitor.visitSingularStringField(value: self.demandID, fieldNumber: 1)
    }
    try { if let v = self._canceledInfoPick {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._canceledInfoDrop {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_SupplyWaypointUpdate.CancelDetail, rhs: Frontend_SupplyWaypointUpdate.CancelDetail) -> Bool {
    if lhs.demandID != rhs.demandID {return false}
    if lhs._canceledInfoPick != rhs._canceledInfoPick {return false}
    if lhs._canceledInfoDrop != rhs._canceledInfoDrop {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_SupplyWaypointUpdate.DemandStationInfoFromPrev: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Frontend_SupplyWaypointUpdate.protoMessageName + ".DemandStationInfoFromPrev"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "demand_id"),
    2: .standard(proto: "stop_idx"),
    3: .standard(proto: "waypoint_seq"),
    4: .standard(proto: "waypoint_lng_lat"),
    5: .standard(proto: "waypoint_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.demandID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.stopIdx) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.waypointSeq) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._waypointLngLat) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.waypointName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.demandID.isEmpty {
      try visitor.visitSingularStringField(value: self.demandID, fieldNumber: 1)
    }
    if self.stopIdx != 0 {
      try visitor.visitSingularInt32Field(value: self.stopIdx, fieldNumber: 2)
    }
    if self.waypointSeq != 0 {
      try visitor.visitSingularInt32Field(value: self.waypointSeq, fieldNumber: 3)
    }
    try { if let v = self._waypointLngLat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.waypointName.isEmpty {
      try visitor.visitSingularStringField(value: self.waypointName, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_SupplyWaypointUpdate.DemandStationInfoFromPrev, rhs: Frontend_SupplyWaypointUpdate.DemandStationInfoFromPrev) -> Bool {
    if lhs.demandID != rhs.demandID {return false}
    if lhs.stopIdx != rhs.stopIdx {return false}
    if lhs.waypointSeq != rhs.waypointSeq {return false}
    if lhs._waypointLngLat != rhs._waypointLngLat {return false}
    if lhs.waypointName != rhs.waypointName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_SupplyWaypoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SupplyWaypoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "supply_id"),
    2: .standard(proto: "stop_idx"),
    3: .standard(proto: "waypoint_seq"),
    4: .standard(proto: "waypoint_lng_lat"),
    5: .standard(proto: "waypoint_name"),
    6: .standard(proto: "waypoint_desc"),
    7: .standard(proto: "waypoint_type"),
    8: .standard(proto: "pick_up_demand_id_list"),
    9: .standard(proto: "drop_off_demand_id_list"),
    10: .standard(proto: "pick_up_user_id_list"),
    11: .standard(proto: "drop_off_user_id_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.supplyID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.stopIdx) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.waypointSeq) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._waypointLngLat) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.waypointName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.waypointDesc) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.waypointType) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.pickUpDemandIDList) }()
      case 9: try { try decoder.decodeRepeatedStringField(value: &self.dropOffDemandIDList) }()
      case 10: try { try decoder.decodeRepeatedInt32Field(value: &self.pickUpUserIDList) }()
      case 11: try { try decoder.decodeRepeatedInt32Field(value: &self.dropOffUserIDList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.supplyID != 0 {
      try visitor.visitSingularInt32Field(value: self.supplyID, fieldNumber: 1)
    }
    if self.stopIdx != 0 {
      try visitor.visitSingularInt32Field(value: self.stopIdx, fieldNumber: 2)
    }
    if self.waypointSeq != 0 {
      try visitor.visitSingularInt32Field(value: self.waypointSeq, fieldNumber: 3)
    }
    try { if let v = self._waypointLngLat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.waypointName.isEmpty {
      try visitor.visitSingularStringField(value: self.waypointName, fieldNumber: 5)
    }
    if !self.waypointDesc.isEmpty {
      try visitor.visitSingularStringField(value: self.waypointDesc, fieldNumber: 6)
    }
    if self.waypointType != .pickDrop {
      try visitor.visitSingularEnumField(value: self.waypointType, fieldNumber: 7)
    }
    if !self.pickUpDemandIDList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pickUpDemandIDList, fieldNumber: 8)
    }
    if !self.dropOffDemandIDList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dropOffDemandIDList, fieldNumber: 9)
    }
    if !self.pickUpUserIDList.isEmpty {
      try visitor.visitPackedInt32Field(value: self.pickUpUserIDList, fieldNumber: 10)
    }
    if !self.dropOffUserIDList.isEmpty {
      try visitor.visitPackedInt32Field(value: self.dropOffUserIDList, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_SupplyWaypoint, rhs: Frontend_SupplyWaypoint) -> Bool {
    if lhs.supplyID != rhs.supplyID {return false}
    if lhs.stopIdx != rhs.stopIdx {return false}
    if lhs.waypointSeq != rhs.waypointSeq {return false}
    if lhs._waypointLngLat != rhs._waypointLngLat {return false}
    if lhs.waypointName != rhs.waypointName {return false}
    if lhs.waypointDesc != rhs.waypointDesc {return false}
    if lhs.waypointType != rhs.waypointType {return false}
    if lhs.pickUpDemandIDList != rhs.pickUpDemandIDList {return false}
    if lhs.dropOffDemandIDList != rhs.dropOffDemandIDList {return false}
    if lhs.pickUpUserIDList != rhs.pickUpUserIDList {return false}
    if lhs.dropOffUserIDList != rhs.dropOffUserIDList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_SupplyWaypoint.SupplyWaypointType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PICK_DROP"),
    1: .same(proto: "CANCEL"),
    2: .same(proto: "PARKING"),
    3: .same(proto: "GARAGE"),
    4: .same(proto: "REST"),
    5: .same(proto: "RELOCATION"),
    6: .same(proto: "PREDICTION"),
    7: .same(proto: "ROTATION"),
    8: .same(proto: "REPAIR"),
    9: .same(proto: "ROUTE"),
  ]
}

extension Frontend_SupplyWaypointPaths: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SupplyWaypointPaths"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "supply_waypoint_path"),
    2: .standard(proto: "get_date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.supplyWaypointPath) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._getDate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.supplyWaypointPath.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.supplyWaypointPath, fieldNumber: 1)
    }
    try { if let v = self._getDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_SupplyWaypointPaths, rhs: Frontend_SupplyWaypointPaths) -> Bool {
    if lhs.supplyWaypointPath != rhs.supplyWaypointPath {return false}
    if lhs._getDate != rhs._getDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_SupplyWaypointPathUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SupplyWaypointPathUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "supply_id"),
    2: .standard(proto: "path_version"),
    3: .standard(proto: "waypoint_version"),
    4: .same(proto: "action"),
    7: .standard(proto: "supply_waypoint_path_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.supplyID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pathVersion) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._waypointVersion) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.supplyWaypointPathList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.supplyID != 0 {
      try visitor.visitSingularInt32Field(value: self.supplyID, fieldNumber: 1)
    }
    try { if let v = self._pathVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._waypointVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.action != .waypointUpdate {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 4)
    }
    if !self.supplyWaypointPathList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.supplyWaypointPathList, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_SupplyWaypointPathUpdate, rhs: Frontend_SupplyWaypointPathUpdate) -> Bool {
    if lhs.supplyID != rhs.supplyID {return false}
    if lhs._pathVersion != rhs._pathVersion {return false}
    if lhs._waypointVersion != rhs._waypointVersion {return false}
    if lhs.action != rhs.action {return false}
    if lhs.supplyWaypointPathList != rhs.supplyWaypointPathList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_SupplyWaypointPathUpdate.PathActionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WAYPOINT_UPDATE"),
    1: .same(proto: "OFFTRACK"),
  ]
}

extension Frontend_SupplyWaypointPath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SupplyWaypointPath"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "supply_id"),
    2: .standard(proto: "waypoint_seq"),
    3: .same(proto: "path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.supplyID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.waypointSeq) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._path) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.supplyID != 0 {
      try visitor.visitSingularInt32Field(value: self.supplyID, fieldNumber: 1)
    }
    if self.waypointSeq != 0 {
      try visitor.visitSingularInt32Field(value: self.waypointSeq, fieldNumber: 2)
    }
    try { if let v = self._path {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_SupplyWaypointPath, rhs: Frontend_SupplyWaypointPath) -> Bool {
    if lhs.supplyID != rhs.supplyID {return false}
    if lhs.waypointSeq != rhs.waypointSeq {return false}
    if lhs._path != rhs._path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_SupplyWaypointEtas: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SupplyWaypointEtas"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "supply_waypoint_eta"),
    2: .standard(proto: "get_date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.supplyWaypointEta) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._getDate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.supplyWaypointEta.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.supplyWaypointEta, fieldNumber: 1)
    }
    try { if let v = self._getDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_SupplyWaypointEtas, rhs: Frontend_SupplyWaypointEtas) -> Bool {
    if lhs.supplyWaypointEta != rhs.supplyWaypointEta {return false}
    if lhs._getDate != rhs._getDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_SupplyWaypointEtaUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SupplyWaypointEtaUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "supply_id"),
    2: .standard(proto: "eta_version"),
    3: .standard(proto: "waypoint_version"),
    4: .same(proto: "action"),
    7: .standard(proto: "supply_waypoint_eta_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.supplyID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._etaVersion) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._waypointVersion) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.supplyWaypointEtaList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.supplyID != 0 {
      try visitor.visitSingularInt32Field(value: self.supplyID, fieldNumber: 1)
    }
    try { if let v = self._etaVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._waypointVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.action != .waypointUpdate {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 4)
    }
    if !self.supplyWaypointEtaList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.supplyWaypointEtaList, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_SupplyWaypointEtaUpdate, rhs: Frontend_SupplyWaypointEtaUpdate) -> Bool {
    if lhs.supplyID != rhs.supplyID {return false}
    if lhs._etaVersion != rhs._etaVersion {return false}
    if lhs._waypointVersion != rhs._waypointVersion {return false}
    if lhs.action != rhs.action {return false}
    if lhs.supplyWaypointEtaList != rhs.supplyWaypointEtaList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_SupplyWaypointEtaUpdate.EtaActionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WAYPOINT_UPDATE"),
    1: .same(proto: "PATH_OFFTRACK"),
    2: .same(proto: "ETA_OFFTRACK"),
  ]
}

extension Frontend_SupplyWaypointEta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SupplyWaypointEta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "supply_id"),
    2: .standard(proto: "waypoint_seq"),
    3: .same(proto: "eta"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.supplyID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.waypointSeq) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._eta) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.supplyID != 0 {
      try visitor.visitSingularInt32Field(value: self.supplyID, fieldNumber: 1)
    }
    if self.waypointSeq != 0 {
      try visitor.visitSingularInt32Field(value: self.waypointSeq, fieldNumber: 2)
    }
    try { if let v = self._eta {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_SupplyWaypointEta, rhs: Frontend_SupplyWaypointEta) -> Bool {
    if lhs.supplyID != rhs.supplyID {return false}
    if lhs.waypointSeq != rhs.waypointSeq {return false}
    if lhs._eta != rhs._eta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_FindPathRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FindPathRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "region_code"),
    2: .standard(proto: "pick_station_id"),
    3: .standard(proto: "drop_station_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.regionCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pickStationID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dropStationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.regionCode != 0 {
      try visitor.visitSingularInt32Field(value: self.regionCode, fieldNumber: 1)
    }
    if !self.pickStationID.isEmpty {
      try visitor.visitSingularStringField(value: self.pickStationID, fieldNumber: 2)
    }
    if !self.dropStationID.isEmpty {
      try visitor.visitSingularStringField(value: self.dropStationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_FindPathRequest, rhs: Frontend_FindPathRequest) -> Bool {
    if lhs.regionCode != rhs.regionCode {return false}
    if lhs.pickStationID != rhs.pickStationID {return false}
    if lhs.dropStationID != rhs.dropStationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_FindPathReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FindPathReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "region_code"),
    2: .same(proto: "path"),
    3: .same(proto: "duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.regionCode) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._path) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.duration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.regionCode != 0 {
      try visitor.visitSingularInt32Field(value: self.regionCode, fieldNumber: 1)
    }
    try { if let v = self._path {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.duration != 0 {
      try visitor.visitSingularDoubleField(value: self.duration, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_FindPathReply, rhs: Frontend_FindPathReply) -> Bool {
    if lhs.regionCode != rhs.regionCode {return false}
    if lhs._path != rhs._path {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_FindMultiPathRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FindMultiPathRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requests"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.requests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_FindMultiPathRequest, rhs: Frontend_FindMultiPathRequest) -> Bool {
    if lhs.requests != rhs.requests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_FindMultiPathReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FindMultiPathReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "replies"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.replies) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.replies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.replies, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_FindMultiPathReply, rhs: Frontend_FindMultiPathReply) -> Bool {
    if lhs.replies != rhs.replies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_WaypointsWithSupply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaypointsWithSupply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "region_code"),
    2: .standard(proto: "supply_id"),
    3: .standard(proto: "waypoint_list"),
    4: .standard(proto: "supply_lng_lat"),
    5: .standard(proto: "supply_node_idx"),
    7: .standard(proto: "arrived_waypoint"),
    6: .standard(proto: "start_time_at_car"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.regionCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.supplyID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.waypointList) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._supplyLngLat) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.supplyNodeIdx) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._startTimeAtCar) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._arrivedWaypoint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.regionCode != 0 {
      try visitor.visitSingularInt32Field(value: self.regionCode, fieldNumber: 1)
    }
    if !self.supplyID.isEmpty {
      try visitor.visitSingularStringField(value: self.supplyID, fieldNumber: 2)
    }
    if !self.waypointList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.waypointList, fieldNumber: 3)
    }
    try { if let v = self._supplyLngLat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.supplyNodeIdx != 0 {
      try visitor.visitSingularInt32Field(value: self.supplyNodeIdx, fieldNumber: 5)
    }
    try { if let v = self._startTimeAtCar {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._arrivedWaypoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_WaypointsWithSupply, rhs: Frontend_WaypointsWithSupply) -> Bool {
    if lhs.regionCode != rhs.regionCode {return false}
    if lhs.supplyID != rhs.supplyID {return false}
    if lhs.waypointList != rhs.waypointList {return false}
    if lhs._supplyLngLat != rhs._supplyLngLat {return false}
    if lhs.supplyNodeIdx != rhs.supplyNodeIdx {return false}
    if lhs._arrivedWaypoint != rhs._arrivedWaypoint {return false}
    if lhs._startTimeAtCar != rhs._startTimeAtCar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_WaypointsWithSupply.Waypoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Frontend_WaypointsWithSupply.protoMessageName + ".Waypoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_idx"),
    2: .standard(proto: "station_id"),
    3: .standard(proto: "station_lng_lat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.nodeIdx) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.stationID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._stationLngLat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.nodeIdx != 0 {
      try visitor.visitSingularInt32Field(value: self.nodeIdx, fieldNumber: 1)
    }
    if !self.stationID.isEmpty {
      try visitor.visitSingularStringField(value: self.stationID, fieldNumber: 2)
    }
    try { if let v = self._stationLngLat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_WaypointsWithSupply.Waypoint, rhs: Frontend_WaypointsWithSupply.Waypoint) -> Bool {
    if lhs.nodeIdx != rhs.nodeIdx {return false}
    if lhs.stationID != rhs.stationID {return false}
    if lhs._stationLngLat != rhs._stationLngLat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_PathWithEtaPerWaypoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PathWithEtaPerWaypoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_list"),
    2: .standard(proto: "duration_list"),
    3: .standard(proto: "eta_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pathList) }()
      case 2: try { try decoder.decodeRepeatedDoubleField(value: &self.durationList) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.etaList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pathList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pathList, fieldNumber: 1)
    }
    if !self.durationList.isEmpty {
      try visitor.visitPackedDoubleField(value: self.durationList, fieldNumber: 2)
    }
    if !self.etaList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.etaList, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_PathWithEtaPerWaypoint, rhs: Frontend_PathWithEtaPerWaypoint) -> Bool {
    if lhs.pathList != rhs.pathList {return false}
    if lhs.durationList != rhs.durationList {return false}
    if lhs.etaList != rhs.etaList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_Supply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Supply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "id"),
    3: .same(proto: "name"),
    5: .same(proto: "state"),
    6: .standard(proto: "update_time"),
    7: .same(proto: "location"),
    8: .standard(proto: "routing_queue_list"),
    9: .standard(proto: "routing_demand_list"),
    10: .standard(proto: "routing_distance_list"),
    11: .standard(proto: "current_passenger"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.routingQueueList) }()
      case 9: try { try decoder.decodeRepeatedStringField(value: &self.routingDemandList) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.routingDistanceList) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.currentPassenger) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.state != .serviceStart {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 5)
    }
    try { if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.routingQueueList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routingQueueList, fieldNumber: 8)
    }
    if !self.routingDemandList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.routingDemandList, fieldNumber: 9)
    }
    if !self.routingDistanceList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routingDistanceList, fieldNumber: 10)
    }
    if self.currentPassenger != 0 {
      try visitor.visitSingularInt32Field(value: self.currentPassenger, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_Supply, rhs: Frontend_Supply) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.state != rhs.state {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs._location != rhs._location {return false}
    if lhs.routingQueueList != rhs.routingQueueList {return false}
    if lhs.routingDemandList != rhs.routingDemandList {return false}
    if lhs.routingDistanceList != rhs.routingDistanceList {return false}
    if lhs.currentPassenger != rhs.currentPassenger {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_Supply.ServiceState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SERVICE_START"),
    1: .same(proto: "SERVICE_END"),
  ]
}

extension Frontend_Supply.RoutingQueue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Frontend_Supply.protoMessageName + ".RoutingQueue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_index"),
    2: .standard(proto: "station_id"),
    3: .standard(proto: "station_priority"),
    4: .standard(proto: "user_id"),
    5: .same(proto: "state"),
    6: .standard(proto: "demand_id"),
    7: .standard(proto: "demand_passenger"),
    8: .standard(proto: "path_index"),
    9: .standard(proto: "path_distance"),
    10: .standard(proto: "estimate_time"),
    11: .standard(proto: "sequence_index"),
    12: .standard(proto: "cancel_segment"),
    13: .standard(proto: "station_name"),
    14: .standard(proto: "station_lng_lat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.nodeIndex) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.stationID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.stationPriority) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.demandID) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.demandPassenger) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.pathIndex) }()
      case 9: try { try decoder.decodeSingularDoubleField(value: &self.pathDistance) }()
      case 10: try { try decoder.decodeSingularDoubleField(value: &self.estimateTime) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.sequenceIndex) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.cancelSegment) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.stationName) }()
      case 14: try { try decoder.decodeSingularMessageField(value: &self._stationLngLat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.nodeIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.nodeIndex, fieldNumber: 1)
    }
    if !self.stationID.isEmpty {
      try visitor.visitSingularStringField(value: self.stationID, fieldNumber: 2)
    }
    if self.stationPriority != 0 {
      try visitor.visitSingularInt32Field(value: self.stationPriority, fieldNumber: 3)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 4)
    }
    if self.state != .start {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 5)
    }
    if !self.demandID.isEmpty {
      try visitor.visitSingularStringField(value: self.demandID, fieldNumber: 6)
    }
    if self.demandPassenger != 0 {
      try visitor.visitSingularInt32Field(value: self.demandPassenger, fieldNumber: 7)
    }
    if self.pathIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.pathIndex, fieldNumber: 8)
    }
    if self.pathDistance != 0 {
      try visitor.visitSingularDoubleField(value: self.pathDistance, fieldNumber: 9)
    }
    if self.estimateTime != 0 {
      try visitor.visitSingularDoubleField(value: self.estimateTime, fieldNumber: 10)
    }
    if self.sequenceIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.sequenceIndex, fieldNumber: 11)
    }
    if self.cancelSegment != false {
      try visitor.visitSingularBoolField(value: self.cancelSegment, fieldNumber: 12)
    }
    if !self.stationName.isEmpty {
      try visitor.visitSingularStringField(value: self.stationName, fieldNumber: 13)
    }
    try { if let v = self._stationLngLat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_Supply.RoutingQueue, rhs: Frontend_Supply.RoutingQueue) -> Bool {
    if lhs.nodeIndex != rhs.nodeIndex {return false}
    if lhs.stationID != rhs.stationID {return false}
    if lhs.stationPriority != rhs.stationPriority {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.state != rhs.state {return false}
    if lhs.demandID != rhs.demandID {return false}
    if lhs.demandPassenger != rhs.demandPassenger {return false}
    if lhs.pathIndex != rhs.pathIndex {return false}
    if lhs.pathDistance != rhs.pathDistance {return false}
    if lhs.estimateTime != rhs.estimateTime {return false}
    if lhs.sequenceIndex != rhs.sequenceIndex {return false}
    if lhs.cancelSegment != rhs.cancelSegment {return false}
    if lhs.stationName != rhs.stationName {return false}
    if lhs._stationLngLat != rhs._stationLngLat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_Supply.RoutingQueue.QueueState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "START"),
    1: .same(proto: "END"),
    2: .same(proto: "CANCEL"),
    3: .same(proto: "RELOCATION"),
    4: .same(proto: "PREDICTION"),
    5: .same(proto: "ROTATION"),
    6: .same(proto: "REST"),
    7: .same(proto: "GARAGE"),
    8: .same(proto: "REPAIR"),
    9: .same(proto: "ROUTE"),
  ]
}

extension Frontend_Supply.RoutingDistance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Frontend_Supply.protoMessageName + ".RoutingDistance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "demand_id"),
    2: .standard(proto: "user_id"),
    3: .same(proto: "state"),
    4: .standard(proto: "demand_node"),
    5: .standard(proto: "recent_node"),
    6: .standard(proto: "init_wait_distance"),
    7: .standard(proto: "init_race_distance"),
    8: .standard(proto: "diff_wait_distance"),
    9: .standard(proto: "diff_race_distance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.demandID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.state) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.demandNode) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.recentNode) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.initWaitDistance) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.initRaceDistance) }()
      case 8: try { try decoder.decodeSingularDoubleField(value: &self.diffWaitDistance) }()
      case 9: try { try decoder.decodeSingularDoubleField(value: &self.diffRaceDistance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.demandID.isEmpty {
      try visitor.visitSingularStringField(value: self.demandID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 2)
    }
    if self.state != 0 {
      try visitor.visitSingularInt32Field(value: self.state, fieldNumber: 3)
    }
    if self.demandNode != 0 {
      try visitor.visitSingularInt32Field(value: self.demandNode, fieldNumber: 4)
    }
    if self.recentNode != 0 {
      try visitor.visitSingularInt32Field(value: self.recentNode, fieldNumber: 5)
    }
    if self.initWaitDistance != 0 {
      try visitor.visitSingularDoubleField(value: self.initWaitDistance, fieldNumber: 6)
    }
    if self.initRaceDistance != 0 {
      try visitor.visitSingularDoubleField(value: self.initRaceDistance, fieldNumber: 7)
    }
    if self.diffWaitDistance != 0 {
      try visitor.visitSingularDoubleField(value: self.diffWaitDistance, fieldNumber: 8)
    }
    if self.diffRaceDistance != 0 {
      try visitor.visitSingularDoubleField(value: self.diffRaceDistance, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_Supply.RoutingDistance, rhs: Frontend_Supply.RoutingDistance) -> Bool {
    if lhs.demandID != rhs.demandID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.state != rhs.state {return false}
    if lhs.demandNode != rhs.demandNode {return false}
    if lhs.recentNode != rhs.recentNode {return false}
    if lhs.initWaitDistance != rhs.initWaitDistance {return false}
    if lhs.initRaceDistance != rhs.initRaceDistance {return false}
    if lhs.diffWaitDistance != rhs.diffWaitDistance {return false}
    if lhs.diffRaceDistance != rhs.diffRaceDistance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_TripPlannerResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TripPlannerResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "return_code"),
    2: .standard(proto: "result_message"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.returnCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resultMessage) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.returnCode != 0 {
      try visitor.visitSingularInt32Field(value: self.returnCode, fieldNumber: 1)
    }
    if !self.resultMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.resultMessage, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_TripPlannerResult, rhs: Frontend_TripPlannerResult) -> Bool {
    if lhs.returnCode != rhs.returnCode {return false}
    if lhs.resultMessage != rhs.resultMessage {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_Trip: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Trip"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "total_price"),
    3: .standard(proto: "transfer_count"),
    4: .standard(proto: "total_distance"),
    5: .standard(proto: "total_time"),
    6: .standard(proto: "aboard_time"),
    7: .standard(proto: "aboard_distance"),
    8: .standard(proto: "walk_time"),
    9: .standard(proto: "walk_distance"),
    10: .standard(proto: "pickup_stop_idx"),
    11: .standard(proto: "dropoff_stop_idx"),
    12: .same(proto: "waypoints"),
    13: .same(proto: "paths"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.totalPrice) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.transferCount) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.totalDistance) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.totalTime) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.aboardTime) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.aboardDistance) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.walkTime) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.walkDistance) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.pickupStopIdx) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.dropoffStopIdx) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.waypoints) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.paths) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.totalPrice != 0 {
      try visitor.visitSingularInt32Field(value: self.totalPrice, fieldNumber: 2)
    }
    if self.transferCount != 0 {
      try visitor.visitSingularInt32Field(value: self.transferCount, fieldNumber: 3)
    }
    if self.totalDistance != 0 {
      try visitor.visitSingularInt32Field(value: self.totalDistance, fieldNumber: 4)
    }
    if self.totalTime != 0 {
      try visitor.visitSingularInt32Field(value: self.totalTime, fieldNumber: 5)
    }
    if self.aboardTime != 0 {
      try visitor.visitSingularInt32Field(value: self.aboardTime, fieldNumber: 6)
    }
    if self.aboardDistance != 0 {
      try visitor.visitSingularInt32Field(value: self.aboardDistance, fieldNumber: 7)
    }
    if self.walkTime != 0 {
      try visitor.visitSingularInt32Field(value: self.walkTime, fieldNumber: 8)
    }
    if self.walkDistance != 0 {
      try visitor.visitSingularInt32Field(value: self.walkDistance, fieldNumber: 9)
    }
    if self.pickupStopIdx != 0 {
      try visitor.visitSingularInt32Field(value: self.pickupStopIdx, fieldNumber: 10)
    }
    if self.dropoffStopIdx != 0 {
      try visitor.visitSingularInt32Field(value: self.dropoffStopIdx, fieldNumber: 11)
    }
    if !self.waypoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.waypoints, fieldNumber: 12)
    }
    if !self.paths.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.paths, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_Trip, rhs: Frontend_Trip) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.totalPrice != rhs.totalPrice {return false}
    if lhs.transferCount != rhs.transferCount {return false}
    if lhs.totalDistance != rhs.totalDistance {return false}
    if lhs.totalTime != rhs.totalTime {return false}
    if lhs.aboardTime != rhs.aboardTime {return false}
    if lhs.aboardDistance != rhs.aboardDistance {return false}
    if lhs.walkTime != rhs.walkTime {return false}
    if lhs.walkDistance != rhs.walkDistance {return false}
    if lhs.pickupStopIdx != rhs.pickupStopIdx {return false}
    if lhs.dropoffStopIdx != rhs.dropoffStopIdx {return false}
    if lhs.waypoints != rhs.waypoints {return false}
    if lhs.paths != rhs.paths {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_Waypoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Waypoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seq"),
    2: .same(proto: "type"),
    3: .same(proto: "lng"),
    4: .same(proto: "lat"),
    5: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.seq) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.lng) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.lat) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seq != 0 {
      try visitor.visitSingularInt32Field(value: self.seq, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if self.lng != 0 {
      try visitor.visitSingularDoubleField(value: self.lng, fieldNumber: 3)
    }
    if self.lat != 0 {
      try visitor.visitSingularDoubleField(value: self.lat, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_Waypoint, rhs: Frontend_Waypoint) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs.type != rhs.type {return false}
    if lhs.lng != rhs.lng {return false}
    if lhs.lat != rhs.lat {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Frontend_LngLat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LngLat"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lng"),
    2: .same(proto: "lat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.lng) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.lat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lng != 0 {
      try visitor.visitSingularDoubleField(value: self.lng, fieldNumber: 1)
    }
    if self.lat != 0 {
      try visitor.visitSingularDoubleField(value: self.lat, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Frontend_LngLat, rhs: Frontend_LngLat) -> Bool {
    if lhs.lng != rhs.lng {return false}
    if lhs.lat != rhs.lat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
